Архитектурный План для Промышленной «Фабрики Агентов»: Стандарты, Среды Исполнения и Механизмы Защиты




Часть I: Стандартизация Проекта Агента: Сравнительный Анализ Схем Мета-Профиля


В этом разделе рассматривается первая и наиболее фундаментальная проблема: создание надежного, масштабируемого и не требующего «изобретения велосипеда» формата для описания АИ-агентов. Мы проанализируем существующие отраслевые стандарты и протоколы, чтобы сформировать исчерпывающую спецификацию для Meta-Profile.yaml.


1.1. Необходимость Стандартизированного Определения Агента


Современная экосистема агентов характеризуется высокой степенью фрагментации. Каждый фреймворк, будь то LangChain, AutoGen или CrewAI, использует собственные, проприетарные форматы для определения агентов, их инструментов и инструкций. Такое положение дел создает изолированные информационные пространства (data silos), что серьезно затрудняет взаимодействие (interoperability) между агентами, созданными с помощью разных технологий.1 Для проекта «Фабрика Агентов», целью которого является массовое и надежное производство разнотипных агентов, такая фрагментация представляет собой критический архитектурный риск.
Отсутствие единого «контракта» для описания агента аналогично ситуации в мире веб-сервисов до появления стандарта OpenAPI (ранее Swagger). Без общего языка для описания API интеграция была дорогостоящей, хрупкой и требовала написания большого количества связующего кода. Внедрение стандартов позволяет решить эту проблему. Исследования показывают, что использование общих схем, таких как OASF, может снизить затраты на интеграцию на 40-60% по сравнению с разработкой кастомных решений.1 Стандартизированная схема является основой для автоматической валидации, обнаружения (discovery) и кросс-платформенного взаимодействия агентов, что является необходимым условием для создания масштабируемой и надежной «Фабрики».1


1.2. Глубокое Погружение: Open Agentic Schema Framework (OASF)


Open Agentic Schema Framework (OASF), представленный в начале 2025 года консорциумом AGNTCY, является наиболее зрелой попыткой создать формальную, расширяемую схему для определения возможностей, метаданных и взаимодействий АИ-агентов.1 Этот фреймворк не просто предлагает формат данных, но и включает в себя инструменты для разработки, валидации схемы и даже «горячей перезагрузки» для ускорения итераций.2 Важно отметить, что OASF во многом вдохновлен Open Cybersecurity Schema Framework (OCSF), что указывает на его ориентацию на надежность, безопасность и расширяемость корпоративного уровня.2
Ключевые Концепции
В основе OASF лежит объект record (запись) — основная структура данных для представления информации об агенте.2 Эта запись аннотируется с помощью следующих ключевых сущностей:
* Skills (Навыки): Описывают, что агент умеет делать. Навыки организованы в иерархическую таксономию (например, nlp.summarization, data.query.sql), что позволяет осуществлять семантический поиск и обнаружение агентов по их функциональным возможностям.1
* Domains (Домены): Определяют предметную область, в которой агент компетентен (например, finance, healthcare, logistics). Это позволяет фильтровать агентов, релевантных для конкретной задачи.2
* Modules (Модули): Гибкий механизм для расширения записи дополнительной информацией, не предусмотренной в базовой схеме. Это обеспечивает перспективную совместимость и адаптацию к новым сценариям использования.2
Структура и Пример
Запись OASF представляет собой JSON-документ, который содержит исчерпывающую информацию об агенте. Ниже приведен пример структуры, основанный на документации AGNTCY 5:


JSON




{
 "schema_version": "0.7.0",
 "name": "my-org/accounting-agent",
 "version": "1.2.0",
 "description": "Агент для обработки счетов и генерации финансовых отчетов.",
 "authors":,
 "created_at": "2025-10-26T10:00:00Z",
 "skills": [
   "data.query.sql",
   "document.parsing.pdf",
   "reporting.generation"
 ],
 "domains": [
   "finance.accounting"
 ],
 "locators": [
   {
     "type": "agent-as-a-service",
     "url": "[URL_REMOVED]"
   },
   {
     "type": "docker-image",
     "url": "registry.my-company.com/agents/accounting:1.2.0"
   }
 ],
 "modules": [
   {
     "name": "llm_dependencies",
     "config": {
       "provider": "Anthropic",
       "model": "claude-3-5-sonnet-latest"
     }
   }
 ]
}

Ключевым аспектом OASF является его интеграция с экосистемой OCI (Open Container Initiative). Записи агентов упаковываются как OCI-совместимые артефакты и адресуются по криптографическому дайджесту (хешу), что гарантирует их неизменность (immutability) и позволяет использовать стандартные реестры контейнеров (например, Docker Hub, Harbor) для их хранения и распространения.6
Архитектурные Последствия
Принятие OASF означает, что «Библиотека Компонентов» должна быть спроектирована не как локальная папка с файлами, а как полноценный «Каталог Агентов» (Agent Directory). Этот каталог будет публиковать OASF-совместимые записи, позволяя другим системам и агентам динамически обнаруживать нужных исполнителей на основе их заявленных навыков и доменов.1 Это закладывает основу для создания федеративной, децентрализованной экосистемы агентов.


1.3. Реализация Корпоративного Уровня: Декларативный Манифест Агента от Microsoft


Если OASF представляет собой общий стандарт для взаимодействия, то Декларативный Манифест Агента от Microsoft является примером его узкоспециализированной реализации для конкретной платформы — Microsoft 365 Copilot.8 Это машиночитаемый JSON-документ (хотя разработчики могут создавать его в формате YAML), который предоставляет большой языковой модели (LLM) все необходимые инструкции, знания и действия для выполнения задач пользователя.8
Манифест имеет строгую, версионированную схему (последняя версия — 1.5) и включает в себя следующие ключевые поля 8:
* version, id, name, description: Базовые метаданные.
* instructions: Детальные системные инструкции для LLM, описывающие поведение агента, его роль и ограничения (до 8000 символов).8
* capabilities: Явное объявление встроенных возможностей, таких как поиск в вебе (web_search), интерпретация кода (code_interpreter) или генерация изображений (graphic_art).8
* actions: Список объектов, идентифицирующих API-плагины, которые предоставляют агенту доступ к внешним системам.8
Этот манифест дает ценное представление о том, что требуется для определения агента промышленного уровня: не только общие метаданные, но и подробные инструкции для модели, явное перечисление возможностей и четкая привязка к внешним инструментам.


1.4. Протоколы для Обнаружения и Взаимодействия: Google A2A Agent Card и MCP


Помимо статических схем определения, для создания динамической системы необходимы протоколы для взаимодействия в реальном времени.
* Google A2A Agent Card: В рамках протокола Agent2Agent (A2A), предназначенного для коммуникации между агентами, «Карта Агента» (Agent Card) играет роль машиночитаемого «резюме» или «визитной карточки».12 Это JSON-файл, который агент публикует (часто по стандартному пути /.well-known/agent.json или /.well-known/agent-card.json) для того, чтобы другие агенты могли его обнаружить.14 Карта содержит описание возможностей агента, URL его эндпоинта и требования к аутентификации, обеспечивая основу для динамического взаимодействия.14
* Anthropic Model Context Protocol (MCP): В отличие от A2A, который регулирует общение агент-агент, MCP стандартизирует общение агент-инструмент.14 MCP создает постоянную среду для правил, разрешений и контекста, позволяя агенту взаимодействовать с API не через жестко закодированные вызовы, а через семантическое понимание их возможностей.1 Его называют «универсальным пультом» для инструментов.12
Таким образом, комплексный Meta-Profile.yaml должен содержать всю информацию, необходимую для динамической генерации A2A Agent Card при развертывании агента, а его инструменты (actions) должны быть доступны через MCP-совместимый интерфейс.


1.5. Сравнительный Анализ: Выбор Правильного Формата Сериализации


Для файла Meta-Profile.yaml, который будут создавать и поддерживать разработчики, выбор формата сериализации имеет большое значение.
* JSON: Является стандартом де-факто для передачи данных между системами. Он строго типизирован и поддерживается практически всеми языками. Однако отсутствие комментариев и более громоздкий синтаксис делают его менее удобным для конфигурационных файлов, поддерживаемых человеком.21
* TOML: Был специально разработан как минималистичный формат для конфигурационных файлов. Он имеет явную типизацию и более чистый синтаксис, чем YAML, для простых структур. Однако он менее распространен и может быть неудобен для описания глубоко вложенных иерархий.21
* YAML: Является надмножеством JSON и обладает наилучшей читаемостью для человека благодаря использованию отступов и поддержке комментариев. Это делает его идеальным для сложных, иерархических конфигураций, какими являются профили агентов. Главный недостаток — неявная типизация, которая может приводить к трудноуловимым ошибкам (например, номер версии 2.0 может быть интерпретирован как число с плавающей точкой, а не строка). Этот риск можно и нужно минимизировать.21
Рекомендация: YAML является оптимальным выбором для Meta-Profile.yaml, который создается и редактируется человеком. Его читаемость и возможность комментирования критически важны для описания сложной логики агента. Однако для устранения рисков, связанных с неявной типизацией, система «Фабрики Агентов» должна на входе валидировать загружаемый YAML-файл на соответствие строгой, заранее определенной схеме (например, JSON Schema). Это сочетает удобство для разработчика с надежностью машины.23
________________
Синтез и Стратегические Выводы
Анализ существующих стандартов показывает, что создание надежного мета-профиля — это не выбор одного стандарта, а их грамотный синтез. Meta-Profile.yaml не должен быть просто аналогом одного из рассмотренных форматов, а должен стать композитной спецификацией, объединяющей лучшие практики из нескольких областей.
1. OASF предоставляет высокоуровневую, интероперабельную схему для описания того, чем является агент: его идентичность, навыки, домены.1
2. OpenAPI определяет, что агент может делать: конкретные функции и инструменты, которые он может вызывать.25
3. A2A Agent Card определяет, как агента можно найти и как с ним взаимодействовать другим агентам.12
Следовательно, архитектурно верным решением будет спроектировать Meta-Profile.yaml как супермножество этих концепций. Он должен содержать OASF-подобную структуру для метаданных, список инструментов, каждый из которых ссылается на свою OpenAPI-спецификацию, и всю необходимую информацию для автоматической генерации A2A Agent Card при развертывании агента.
Более того, этот подход выявляет важную параллель: жизненный цикл определения агента полностью повторяет жизненный цикл разработки программного обеспечения.
1. Meta-Profile.yaml — это исходный код.10
2. Схема (основанная на OASF и др.) — это спецификация языка.2
3. «Фабрика Агентов» — это компилятор и сборщик, который превращает YAML в развертываемый артефакт.
4. Этот артефакт, подобно контейнерному образу, публикуется в «Каталоге» или «Реестре», который функционирует аналогично Docker Hub.5
Это означает, что инфраструктура вокруг «Фабрики Агентов» должна включать в себя систему контроля версий для профилей, линтинг и валидацию по схеме, а также конвейер сборки и публикации (CI/CD), как и в любом современном программном проекте.
Таблица 1: Сравнительный Анализ Стандартов Определения и Обнаружения Агентов
	

	

	

	

	

	Стандарт
	Основное Назначение
	Формат Данных
	Ключевые Концепции
	Преимущества для «Фабрики Агентов»
	Ограничения
	OASF
	Стандартизация метаданных и возможностей для интероперабельности
	JSON (упакованный в OCI)
	record, skills, domains, modules, digest
	Создает основу для федеративного каталога агентов; сильная, расширяемая таксономия; неизменяемость артефактов.
	Все еще является развивающимся стандартом; требует инфраструктуры реестра OCI.
	Microsoft Declarative Manifest
	Описание агентов для конкретной платформы (M365 Copilot)
	JSON / YAML
	instructions, capabilities, actions (плагины)
	Отличный пример промышленной реализации; детализированные инструкции для LLM; четкое разделение встроенных и внешних возможностей.
	Привязан к экосистеме Microsoft; менее универсален для гетерогенной среды.
	A2A Agent Card
	Динамическое обнаружение и согласование взаимодействия между агентами
	JSON
	agentProvider, agentCapabilities, securitySchemes, agentInterface
	Стандартизирует "рукопожатие" между агентами; позволяет создавать децентрализованные системы; публикуется по стандартному URI.
	Фокусируется на обнаружении, а не на полном внутреннем определении агента; является частью более крупного протокола A2A.
	________________


Часть II: Архитектура Производственного Цеха: Динамические Среды Исполнения и Фреймворки Оркестрации


После стандартизации «чертежа» агента, следующей задачей является проектирование «станка» — динамической среды исполнения или «Агента-Исполнителя». Этот компонент должен быть способен «оживлять» агентов на основе их профилей, обеспечивая безопасность, масштабируемость и надежность.


2.1. Фундаментальные Принципы: «Среда Исполнения с Динамическим Жизненным Циклом»


Современное понимание архитектуры агента выходит за рамки простого кода. Агент — это полноценное приложение с состоянием. Формула Агент = Модель + Инструкции + Инструменты + Среда исполнения подчеркивает, что среда исполнения (Runtime) является первоклассным, неотъемлемым компонентом.27 Традиционная статическая инфраструктура не подходит для агентных систем. Вместо этого требуется «Среда исполнения с динамическим жизненным циклом» (Runtime with a Dynamic Lifecycle), которая адаптируется к меняющимся условиям и поддерживает непрерывное выполнение, управление состоянием и динамическое взаимодействие с инструментами.27
Ключевые требования к такой среде:
* Безопасность: Изоляция и сандбоксинг (песочница) являются абсолютно необходимыми. Среда должна предотвращать «побег ИИ» (AI escape), безопасно выполнять сгенерированный код и жестко контролировать доступ к файловой системе, сети и системным ресурсам (ЦП, память).27
* Масштабируемость и Гибкость: Среда должна автоматически выделять и масштабировать ресурсы в зависимости от рабочей нагрузки. Она должна быть способна на лету интегрировать новые модели, инструменты и инструкции, загруженные из профилей агентов, без необходимости перезапуска или перекомпиляции.27
* Управление Состоянием (State Management): Агенты часто участвуют в многоходовых диалогах или выполняют длительные задачи. Среда исполнения обязана поддерживать и обновлять состояние агента на протяжении всего его жизненного цикла. Это отличает ее от безсостоятельных (stateless) веб-серверов.27


2.2. Архитектурный Паттерн: Агент как Услуга (AaaS)


На макроуровне «Фабрика Агентов» реализует архитектурный паттерн «Агент как Услуга» (Agent as a Service, AaaS). Этот подход инкапсулирует интеллектуального агента в сервис, который может быть инстанцирован, опрошен и с которым можно взаимодействовать по требованию через API.30 Это позволяет рассматривать каждого сгенерированного агента (например, «Бухгалтер» или «Поисковик») как отдельный микросервис.
Ключевые компоненты архитектуры AaaS 30:
* Модули Восприятия (Perception): Отвечают за сбор внешней и внутренней информации перед действием. Основной технологией здесь является Retrieval-Augmented Generation (RAG) для извлечения контекста из баз знаний, документов и баз данных.
* Планирование (Planning): Модуль, отвечающий за декомпозицию высокоуровневых целей на последовательность выполнимых шагов или подзадач. Для этого используются такие техники, как Chain-of-Thought или графовые планировщики.
* Исполнение (Execution): Компонент, отвечающий за использование инструментов (Tool Use) через вызовы API, запуск функций или выполнение кода. Это позволяет агенту воздействовать на внешний мир.
* Оркестрация (Orchestration): Ядро среды исполнения. Этот слой управляет жизненным циклом, потоком выполнения, коммуникацией и состоянием агента или системы из нескольких агентов. Он координирует работу всех остальных модулей.
Для «Фабрики», обслуживающей множество пользователей или отделов, критически важна многопользовательская (multi-tenant) архитектура. Необходимо сделать стратегический выбор между различными моделями изоляции:
* Полностью общая архитектура: Все арендаторы используют один и тот же экземпляр модели и инфраструктуры. Максимальная экономическая эффективность, но низкая изоляция и кастомизация.31
* Гибридная архитектура: Общая модель ИИ, но изолированные данные для каждого арендатора. Это хороший компромисс между стоимостью и безопасностью.31
* Полностью изолированная архитектура: У каждого арендатора свой собственный стек, включая модель. Максимальная безопасность и кастомизация, но самые высокие затраты и сложность в управлении.32


2.3. Глубокое Погружение в Фреймворки: Сравнительный Анализ


Выбор основного фреймворка определит архитектуру и сложность реализации «Агента-Исполнителя».
* LangChain / LangGraph: Это наиболее зрелый и широко распространенный фреймворк с самой большой экосистемой интеграций.33 LangChain предоставляет высокоуровневые абстракции, такие как create_react_agent, для быстрой разработки агентов.35 Для более сложных, циклических и управляемых состоянием систем предназначен LangGraph, который моделирует логику агента в виде графа, где каждый узел — это функция или вызов LLM.33 Ключевой для динамической загрузки является возможность конструировать цепочки во время выполнения с помощью RunnableLambda, которая может возвращать другие исполняемые объекты в зависимости от входных данных.37
* LlamaIndex: Хотя LlamaIndex предоставляет общие возможности для создания агентов, его основная сила заключается в построении агентов, ориентированных на данные (data-centric), особенно для сложных RAG-пайплайнов.34 Он предлагает гибкие SDK и ценится за детальный контроль над процессами индексации и извлечения данных.38 В отличие от LangChain, у LlamaIndex нет явного паттерна «загрузки из конфигурации»; его подход более программный и ориентирован на код.40
* Agno: Этот фреймворк напрямую решает задачу создания производственной среды исполнения. Он поставляется с готовым сервером на базе FastAPI (называемым AgentOS) и интегрированной панелью управления для мониторинга и тестирования.43 Agno делает акцент на высокой производительности (очень быстрое создание экземпляра агента и низкое потребление памяти), приватности (работает полностью в облаке пользователя) и поддержке полного жизненного цикла {сборка → запуск → развертывание}.43 Его архитектура изначально спроектирована для масштабируемых, многоагентных систем с сохранением состояния.46
* crewAI и другие многоагентные фреймворки: Такие фреймворки, как crewAI, специально разработаны для оркестрации ролевых, совместно работающих агентов.33 Они вводят такие концепции, как роли, общий контекст и пошаговые рабочие процессы, что является важным паттерном для сложных задач, которые не может решить один агент.
________________
Синтез и Стратегические Выводы
Выбор фреймворка для «Агента-Исполнителя» — это фундаментальное архитектурное решение, определяющее компромисс между гибкостью разработки и готовностью к промышленной эксплуатации.
1. LangChain предлагает максимальную гибкость и самую богатую экосистему. Он предоставляет все необходимые «кирпичики»: AgentExecutor, разнообразные инструменты, типы памяти и т.д..34 Однако сборка из этих компонентов масштабируемой, безопасной, многопользовательской среды исполнения — это значительная инженерная задача, которая полностью ложится на плечи разработчика.
2. Agno, напротив, предлагает более «закрытый», но готовый к использованию продукт. Он напрямую предоставляет среду исполнения на FastAPI (AgentOS), панель управления и слои для сохранения состояния.43 Это значительно ускоряет путь к промышленной эксплуатации, но может быть менее гибким, если его архитектурные решения вступают в конфликт с существующей инфраструктурой.
Таким образом, выбор стоит не в плоскости «что лучше?», а в плоскости «хотим ли мы самостоятельно строить инфраструктуру среды исполнения, используя примитивы LangChain, или же мы хотим адаптировать под себя готовую архитектуру, такую как Agno?».
Кроме того, важно понимать, что «Динамическая Среда Исполнения» — это, по своей сути, оркестратор с состоянием, а не безсостоятельный веб-сервер.
1. Простой веб-сервер обрабатывает независимые запросы. Агент же ведет многоходовые диалоги и выполняет длительные задачи.27
2. Фреймворки, такие как LangGraph и Agno, явно моделируют систему как конечный автомат или граф, где каждый шаг изменяет сохраняемое состояние.33
3. Это означает, что ядро сервера «Агент-Исполнитель» должно не просто загрузить профиль и выполнить один вызов модели. Оно должно управлять сессией или потоком 29, сохранять его состояние между вызовами (например, в базе данных, такой как SQLite или Redis) и восстанавливать состояние агента при последующих запросах. Это накладывает серьезные требования на дизайн сервера, требуя наличия надежного слоя управления состоянием.
Таблица 2: Архитектурное Сравнение Ведущих Фреймворков/Сред Исполнения для Агентов
	

	

	

	

	

	Фреймворк
	Основная Архитектурная Парадигма
	Ключевые Особенности для Динамической Загрузки
	Управление Состоянием
	Масштабируемость/Производительность
	Готовность к Промышленной Эксплуатации
	LangChain / LangGraph
	Гибкая, компонентная оркестрация (цепочки/графы)
	RunnableLambda для динамического построения цепочек; обширные API для сборки агентов из примитивов.
	Множество встроенных и сторонних интеграций для памяти (in-memory, Redis, SQL), но требует ручной настройки.
	Масштабируемость зависит от реализации разработчика. LangGraph лучше подходит для сложных, долгоживущих задач.
	Предоставляет строительные блоки, но не готовую к развертыванию среду. Требует значительных инженерных усилий.
	LlamaIndex
	Ориентированность на данные; продвинутые RAG-пайплайны
	Программное создание агентов и инструментов; меньше фокуса на декларативной загрузке из конфига.
	Встроенные компоненты для управления состоянием в контексте RAG и чат-сессий.
	Высокая производительность для задач индексации и извлечения данных.
	Гибкий SDK для интеграции в существующие приложения, но не предоставляет готовую среду исполнения.
	Agno
	Высокопроизводительная среда исполнения "все-в-одном" (AgentOS)
	Декларативное определение агентов, команд и рабочих процессов, которые загружаются в рантайм.
	Встроенная персистентная база данных (SQLite по умолчанию) для сессий, состояний и памяти агентов.
	Оптимизирован для низкой задержки и малого потребления памяти; асинхронный FastAPI-сервер, горизонтально масштабируемый.
	Высокая; поставляется с готовым FastAPI-сервером, панелью управления и дизайном, ориентированным на приватность.
	________________


Часть III: Формирование Арсенала: Продвинутое Управление Библиотекой Компонентов


Этот раздел посвящен решению проблемы управления «Библиотекой Компонентов». Мы перейдем от эвристического подхода с индексацией .py файлов к созданию профессионального, масштабируемого и динамического решения.


3.1. За Пределами Индексации Файлов: Парадигма «Реестр» vs. «Индекс»


Для начала необходимо внести ясность в терминологию.
* Реестр (Registry): В традиционном понимании, это статичный, курируемый человеком список доступных компонентов (инструментов, промптов, конституций). Он подразумевает наличие известных, заранее определенных активов. Доступ к ним обычно осуществляется по имени.50
* Индекс (Index): В современном агентном контексте, это машино-поисковое представление этих компонентов, как правило, в виде векторных эмбеддингов их описаний. Индекс обеспечивает динамическое обнаружение на основе семантической близости, а не простого совпадения имен.52
Ваша первоначальная идея индексировать .py файлы с помощью RAG уже интуитивно близка к правильному подходу. Однако для создания надежной системы необходимо формализовать этот процесс. Цель — создать не просто реестр, а динамический Семантический Индекс компонентов.


3.2. Лучшие Практики Определения и Управления Инструментами


Качество и надежность агента напрямую зависят от качества его инструментов.
* Ясность и Область Применения: Инструменты должны иметь четкие, описательные имена и подробные docstrings. LLM полностью полагается на этот текст, чтобы понять, когда и как использовать инструмент.51 Каждый инструмент должен иметь одну, четко определенную зону ответственности. Сложные задачи следует разбивать на несколько простых инструментов.50
* Проектирование на Основе Схем: Инструменты должны иметь строгие контракты на ввод и вывод, в идеале определенные с помощью схем, таких как Pydantic или JSON Schema.51 Это позволяет проводить автоматическую валидацию и генерировать более точные промпты для LLM. Использование спецификации OpenAPI для описания инструментов, представляющих собой API-вызовы, является отраслевым стандартом.25
* Poka-Yoke (Защита от ошибок): Проектируйте инструменты так, чтобы ими было сложно воспользоваться неправильно. Для детерминированных задач, таких как математические вычисления, сравнение дат или форматирование, всегда используйте инструмент, а не полагайтесь на вероятностную природу LLM.51 Обрабатывайте ошибки и нулевые значения внутри самого инструмента, предоставляя агенту понятную обратную связь.55
* Версионирование и Управление: Поддерживайте строгий контроль версий для инструментов. Это обеспечивает воспроизводимость поведения агента и позволяет связывать результаты тестов и аудита с конкретными версиями инструментов.23


3.3. Агентный RAG как Динамический Селектор Инструментов


Этот паттерн выводит использование RAG за рамки простого извлечения знаний. Здесь агент использует механизм извлечения (retrieval) для поиска наиболее релевантных инструментов для выполнения текущей подзадачи.52
Механизм работы:
1. Индексация: Описания (docstrings) и схемы (например, OpenAPI или Pydantic) всех доступных в библиотеке инструментов преобразуются в векторные эмбеддинги и сохраняются в векторной базе данных.
2. Запрос: Когда перед агентом встает задача (например, «Покажи мне динамику акций Apple за последний месяц и сравни с новостным фоном»), он не пытается сразу вызвать конкретный инструмент. Вместо этого он формирует семантический запрос к индексу инструментов (например, «получить исторические котировки акций по тикеру» или «найти последние новости о компании»).
3. Извлечение и Выбор: Векторная база данных возвращает k наиболее семантически близких инструментов (например, get_stock_history, search_financial_news).
4. Исполнение: Агент анализирует предложенные инструменты, их параметры и выбирает наиболее подходящий для выполнения следующего шага.
Для оркестрации этого процесса используются специализированные типы агентов 56:
* Агенты-Маршрутизаторы (Routing Agents): Принимают первоначальный запрос пользователя и решают, какой инструмент или даже какой другой специализированный агент должен его обработать.
* Агенты-Планировщики Запросов (Query Planning Agents): Декомпозируют сложный запрос на несколько подзадач, для каждой из которых может потребоваться свой инструмент.
Фреймворки, такие как LangGraph и LlamaIndex, предоставляют примитивы для реализации этого паттерна. Например, можно создать узел в графе, который выполняет семантический поиск по индексу инструментов перед основным шагом рассуждения (reasoning).53
________________
Синтез и Стратегические Выводы
Проектирование библиотеки компонентов — это не создание пассивного хранилища кода. Это создание активного, опрашиваемого сервиса, который является неотъемлемой частью цикла рассуждений агента.
1. Первоначальная идея индексации .py файлов рассматривает библиотеку как статический источник.
2. Продвинутый паттерн (Агентный RAG для выбора инструментов) показывает, что агент взаимодействует с библиотекой во время выполнения.52
3. Агент формирует запрос, отправляет его в индекс компонентов и получает в ответ список кандидатов-инструментов.
4. Это означает, что библиотека должна быть спроектирована как высокопроизводительный сервис (скорее всего, на базе векторной СУБД), который тесно интегрирован со средой исполнения агента. Это не просто папка с файлами, а живой API-эндпоинт.
Кроме того, качество текстовых описаний инструментов становится основным фактором, определяющим производительность и надежность агента.
1. В системе, основанной на семантическом поиске, текстовое описание инструмента — это единственная информация, на которую может опереться механизм извлечения. Плохо описанный инструмент никогда не будет выбран, независимо от того, насколько хорошо он написан.
2. Лучшие практики от Anthropic и других лабораторий подчеркивают необходимость писать описания инструментов так, как если бы они предназначались для младшего разработчика в команде: с примерами, описанием крайних случаев и четкими границами ответственности.54
3. Таким образом, «формирование арсенала» в равной степени является задачей написания превосходной документации и метаданных, а не только кода. Это повышает роль технического писательства до уровня ключевой инженерной практики в разработке агентов.
________________


Часть IV: Обеспечение Доверия и Безопасности: Фреймворк для Автоматизированного Аудита Агентов


Этот раздел предлагает четкий путь для замены ручного внутреннего аудита на стандартизированный, автоматизированный конвейер QA и Red Teaming, чтобы гарантировать безопасность и надежность агентов, создаваемых «Фабрикой».


4.1. Развивающийся Ландшафт Уязвимостей Агентов


Для систематизации процесса аудита необходимо опираться на стандартные таксономии рисков. Одним из таких стандартов является OWASP Top 10 для LLM-приложений. Он предоставляет структурированный подход к анализу безопасности агентов, охватывая такие уязвимости, как «Внедрение промптов» (Prompt Injection), «Небезопасная обработка вывода» (Insecure Output Handling), «Уклонение от ограничений агента» (Agent Evasion) и другие.57 Использование этой таксономии позволяет говорить на одном языке с мировым сообществом по кибербезопасности и проводить аудит целенаправленно.


4.2. Глубокое Погружение в Фреймворки: Microsoft PyRIT


PyRIT (Python Risk Identification Tool) — это открытый фреймворк от Microsoft, разработанный для того, чтобы дать возможность специалистам по безопасности и инженерам проактивно выявлять риски в генеративных АИ-системах.59 Он не просто набор тестов, а полноценная, расширяемая архитектура для организации и автоматизации атак.60
Методология и Архитектура:
PyRIT состоит из нескольких ключевых компонентов, которые можно комбинировать для создания сложных сценариев тестирования 60:
* Targets (Цели): Эндпоинты тестируемых агентов или моделей.
* Attack Strategies (Стратегии атак) / Executors: Реализуют комплексные, часто многоходовые, техники атак, координируя работу других компонентов.
* Prompt Converters (Конвертеры промптов): Модули, которые преобразуют «чистые» вредоносные промпты в замаскированные варианты для обхода защитных механизмов. Примеры включают кодирование в Base64, использование Leetspeak, ROT13, ASCII-арт и другие.62
* Scorers (Оценщики): Компоненты, которые автоматически оценивают ответ агента на атаку. Оценка может быть бинарной (удалось/не удалось), по шкале (например, шкала Лайкерта) или на основе классификации контента.62
* Memory (Память): Позволяет сохранять состояние многоходовых атак и передавать информацию между шагами.63
PyRIT позволяет автоматизировать процесс, который ранее выполнялся вручную: генерацию тысяч вариаций атак, их отправку на целевую систему и автоматическую оценку результатов.65


4.3. Глубокое Погружение в Фреймворки: DeepTeam


DeepTeam — это еще один открытый фреймворк для Red Teaming, который использует принципиально интересный подход: он использует LLM не только для оценки ответов, но и для симуляции самих атак.57 Он работает на базе фреймворка для оценки LLM под названием DeepEval.
Методология и Особенности:
* Динамическая Генерация Атак: В отличие от систем, использующих статические наборы данных с вредоносными промптами, DeepTeam генерирует атаки динамически во время тестирования. Это позволяет создавать уникальные и непредсказуемые сценарии, адаптированные под конкретную уязвимость.66
* Широкое Покрытие Уязвимостей: DeepTeam из коробки поддерживает тестирование на более чем 40 типов уязвимостей, включая различные виды предвзятости (Bias), утечку персональных данных (PII Leakage), дезинформацию и другие.57
* Продвинутые Методы Атак: Фреймворк реализует более 10 методов атак, включая как одноходовые (Prompt Injection), так и сложные многоходовые (conversational) джейлбрейки, такие как Linear Jailbreaking и Crescendo.57


4.4. За Пределами Инструментов: Использование Академических и Отраслевых Бенчмарков Безопасности


В то время как фреймворки, такие как PyRIT и DeepTeam, выполняют тесты, бенчмарки позволяют измерить производительность агента по сравнению с общепринятым стандартом. Интеграция с бенчмарками предоставляет объективные доказательства безопасности и надежности агента.
Ключевые инициативы в этой области:
* Stanford HAI (Институт ИИ, ориентированного на человека): Ведет исследования по созданию бенчмарков для критически важных с точки зрения безопасности приложений, например, в здравоохранении. Их работа фокусируется на оценке способности агентов выполнять реальные задачи и анализе типов совершаемых ошибок.68
* METR (Model Evaluation & Threat Research): Некоммерческая организация, занимающаяся измерением автономных возможностей ИИ и катастрофических рисков. Они предлагают метрики, такие как «длина задачи, которую агент может выполнить автономно», что является показателем его надежности и продвинутости.72
* Future of Life Institute (FLI) AI Safety Index: Предоставляет высокоуровневую оценку ведущих ИИ-лабораторий по их практикам безопасности. Хотя это не прямой бенчмарк для агента, он помогает понять приоритеты в области оценки рисков.73
________________
Синтез и Стратегические Выводы
Для построения комплексной стратегии аудита необходимо реализовать два различных контура тестирования: «внутренний контур» для непрерывной разработки и «предварительный контур» для валидации перед развертыванием.
1. Фреймворки, такие как PyRIT и DeepTeam, идеально подходят для автоматизированного «внутреннего контура». Их можно интегрировать в CI/CD конвейер для запуска набора регрессионных тестов безопасности при каждом обновлении профиля агента или его инструментов. Это позволяет обнаруживать уязвимости на ранних стадиях разработки.
2. Академические и отраслевые бенчмарки (от Stanford, METR и др.) лучше подходят для менее частого, но более строгого «предварительного контура». Перед выпуском нового класса агентов (например, «Финансовый Аналитик») его следует оценить на этих внешних бенчмарках, чтобы измерить его возможности и безопасность по сравнению с современным уровнем техники.
Такая двухконтурная стратегия обеспечивает баланс между скоростью разработки (внутренний контур) и строгой, объективной валидацией (предварительный контур), создавая зрелый процесс QA.
Кроме того, сам «аудитор» может быть реализован как агент.
1. Методологии PyRIT и DeepTeam по своей сути представляют собой взаимодействие «атакующего» LLM, который генерирует промпты, и «целевого» LLM, который на них отвечает.60
2. Этот паттерн «Агент Red Team» является мощной абстракцией. Модуль «Авто-Аудит» в «Фабрике» может быть реализован как специализированный агент.
3. Этот «Агент-Аудитор» может быть сконфигурирован с собственным профилем, инструментами (стратегиями атак из PyRIT/DeepTeam) и целями (например, «попытаться извлечь персональные данные из Агента-Бухгалтера»). Такой подход позволяет использовать ту же инфраструктуру «Фабрики» для создания как производственных агентов, так и агентов, которые их тестируют, создавая самоподдерживающуюся и масштабируемую экосистему тестирования.
Таблица 3: Сравнение Фреймворков для Автоматизированного Red Teaming
	

	

	

	

	

	Фреймворк
	Основная Методология
	Ключевые Архитектурные Компоненты
	Покрытие Уязвимостей
	Основной Сценарий Использования
	Сложность Интеграции
	Microsoft PyRIT
	Систематическая оркестрация атак на целевые системы
	Orchestrator, Target, Prompt Converters, Scorer, Memory
	Широкий спектр атак, особенно на обход защитных механизмов (jailbreaking, prompt injection) через трансформацию промптов.
	Интеграция в CI/CD для автоматизированного регрессионного тестирования безопасности; систематические исследования уязвимостей.
	Средняя; требует понимания модульной архитектуры и конфигурации конвейера атаки.
	DeepTeam
	Использование LLM для динамической симуляции атак и оценки ответов
	model_callback, Vulnerability, Attack, Metric
	Более 40 типов уязвимостей, включая предвзятость, утечку PII, дезинформацию; поддержка многоходовых атак.
	Быстрое и гибкое тестирование на широкий спектр рисков без необходимости готовить датасеты; исследовательское тестирование.
	Низкая; требует определения простой функции-обертки для тестируемой системы.
	________________


Часть V: Синтез и Стратегический План для «Фабрики Агентов»


В заключительном разделе мы объединим выводы из предыдущих частей в единое, целостное архитектурное видение и предложим высокоуровневый план реализации проекта «Фабрика Агентов».


5.1. Интегрированное Архитектурное Видение


Целостная архитектура «Фабрики Агентов» представляет собой конвейер, где каждый компонент выполняет свою четко определенную роль, обеспечивая надежность и масштабируемость всего процесса.
1. Входная Спецификация (Meta-Profile.yaml): Разработчик определяет агента с помощью человекочитаемого YAML-файла. Эта спецификация является гибридной, основанной на лучших практиках OASF (для метаданных и возможностей), OpenAPI (для определения инструментов) и содержит информацию для генерации A2A Agent Card (для обнаружения).
2. Ядро «Фабрики Агентов» (Конструктор): Этот сервис принимает на вход Meta-Profile.yaml, валидирует его на соответствие схеме и использует выбранный фреймворк-оркестратор (например, Agno или LangGraph) для компиляции профиля в исполняемый агентский объект.
3. Динамическая Среда Исполнения («Агент-Исполнитель»): Это масштабируемый, многопользовательский сервер, который принимает скомпилированный объект агента и управляет его жизненным циклом. Он отвечает за обработку входящих запросов, управление состоянием сессий и взаимодействие с другими компонентами.
4. Семантический Индекс Компонентов: Во время выполнения «Агент-Исполнитель» обращается к этому сервису (реализованному на базе векторной СУБД) для динамического обнаружения и привязки наиболее релевантных инструментов к агенту в зависимости от текущей задачи.
5. Автоматизированный Конвейер Аудита: После развертывания эндпоинта агента, этот конвейер автоматически запускает набор тестов безопасности с использованием фреймворка, такого как PyRIT или DeepTeam. Он имитирует атаки и оценивает устойчивость агента к известным уязвимостям, генерируя отчет о рисках.
Эта архитектура превращает процесс создания агента из кустарного в промышленный, обеспечивая стандартизацию, автоматизацию и контроль качества на каждом этапе.


5.2. Поэтапный План Реализации


Реализацию такого комплексного проекта целесообразно разбить на несколько логических этапов.
* Этап 1: Создание Фундамента
   * Цель: Создать минимально жизнеспособный продукт (MVP) для производства и запуска одного типа агентов.
   * Задачи:
      1. Определить и задокументировать первую версию схемы Meta-Profile.yaml.
      2. Выбрать и внедрить основной фреймворк для среды исполнения (например, Agno для быстрого старта или LangChain/LangGraph для максимальной гибкости).
      3. Развернуть однопользовательскую версию «Агента-Исполнителя».
      4. Создать начальную версию Семантического Индекса Компонентов с несколькими базовыми инструментами.
* Этап 2: Автоматизация и Масштабирование
   * Цель: Автоматизировать процессы и подготовить инфраструктуру к масштабированию.
   * Задачи:
      1. Реализовать CI/CD конвейер для «Фабрики», который автоматически собирает и развертывает агентов при изменении их профилей.
      2. Интегрировать фреймворк для автоматического аудита (например, DeepTeam) во «внутренний контур» CI/CD для регрессионного тестирования.
      3. Модифицировать архитектуру «Агента-Исполнителя» для поддержки многопользовательского режима (multi-tenancy) с изоляцией данных.
* Этап 3: Интероперабельность и Федерация
   * Цель: Обеспечить возможность взаимодействия созданных агентов друг с другом и с внешними системами.
   * Задачи:
      1. Реализовать автоматическую генерацию A2A Agent Cards для всех развернутых агентов.
      2. Создать внутренний «Каталог Агентов» на основе записей OASF для централизованного обнаружения.
      3. Провести эксперименты по созданию сложных, совместных рабочих процессов, в которых несколько агентов из «Фабрики» взаимодействуют друг с другом для решения комплексной задачи.


5.3. Итоговые Рекомендации


Для успешного проектирования и создания надежной «Фабрики Агентов» рекомендуется придерживаться следующих стратегических принципов и технологических выборов:
1. Принять гибридный подход к стандартизации: Не пытайтесь выбрать один-единственный стандарт для Meta-Profile.yaml. Вместо этого создайте композитную схему, которая включает в себя метаданные в стиле OASF, определения инструментов через OpenAPI и информацию для генерации A2A Agent Card. Это обеспечит как внутреннюю согласованность, так и внешнюю интероперабельность.
2. Выбрать фреймворк среды исполнения на основе стратегических приоритетов: Если главная цель — максимально быстрое создание готового к эксплуатации продукта с минимальными затратами на инфраструктуру, Agno с его встроенным AgentOS является предпочтительным выбором. Если же приоритетом является максимальная гибкость, контроль и интеграция с широкой экосистемой, то следует выбрать LangChain/LangGraph, осознавая необходимость самостоятельной разработки инфраструктуры среды исполнения.
3. Проектировать библиотеку компонентов как динамический сервис: Откажитесь от идеи статического репозитория файлов. С самого начала проектируйте «Библиотеку Компонентов» как семантически индексируемый сервис на базе векторной СУБД, который агенты будут опрашивать в реальном времени для выбора инструментов.
4. Внедрить двухконтурную систему автоматического аудита: Интегрируйте PyRIT или DeepTeam в CI/CD конвейер для постоянного регрессионного тестирования безопасности («внутренний контур»). Периодически проводите валидацию на внешних академических бенчмарках (например, от Stanford HAI) для объективной оценки надежности («предварительный контур»).
Следуя этим рекомендациям, можно перейти от состояния «неуверенности» к созданию четкого, обоснованного и надежного архитектурного плана, который позволит построить «Фабрику Агентов», способную производить безопасные, надежные и масштабируемые АИ-системы промышленного уровня.
Источники
1. Some of the open source standards used with AI agents or agentic frameworks | Fabrix.ai, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
2. agntcy/oasf: Open Agentic Schema Framework - GitHub, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
3. github.com, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
4. Open Agentic Schema Framework - Agntcy, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
5. Hosted Outshift Agent Directory, powered by AGNTCY, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
6. Evolution of AI Agent Registry Solutions: Centralized, Enterprise, and Distributed Approaches - arXiv, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
7. (PDF) The AGNTCY Agent Directory Service: Architecture and Implementation, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
8. Declarative agent schema 1.2 for Microsoft 365 Copilot | Microsoft ..., дата последнего обращения: октября 29, 2025, [URL_REMOVED]
9. Declarative agents for Microsoft 365 Copilot overview, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
10. Build Security Copilot agents by uploading a YAML - Microsoft Learn, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
11. Declarative agent schema 1.5 for Microsoft 365 Copilot, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
12. What Is the A2A (Agent2Agent) Protocol and How It Works - Descope, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
13. What is A2A protocol (Agent2Agent)? - IBM, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
14. Getting Started with Agent2Agent (A2A) Protocol: A Purchasing Concierge and Remote Seller Agent Interactions on Cloud Run and Agent Engine | Google Codelabs, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
15. Add your AI agent's Agent Card | Google Cloud Marketplace Partners, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
16. Agent Card, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
17. Specification - A2A Protocol, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
18. Introducing Agent2Agent (A2A): Understanding Google's Protocol for AI Collaboration, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
19. Agent2Agent (A2A) Protocol, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
20. The Architectural Shift: AI Agents Become Execution Engines While Backends Retreat to Governance - InfoQ, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
21. An In-depth Comparison of JSON, YAML, and TOML | AnBowell, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
22. YAML vs TOML : r/devops - Reddit, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
23. Agent Action Schema: The Foundation of Intelligent Automation - Adopt AI, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
24. How to parse YAML output - Install LangChain, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
25. Use an external API with AI Agents - Kustomer Help Center, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
26. OpenAPI Specification: A Crucial Tool in the Age of AI | Baresquare, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
27. AI Agents Need a Runtime With a Dynamic Lifecycle—Here's Why, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
28. Building Scalable AI Agents: Design Patterns With Agent Engine On Google Cloud, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
29. openai/openai-agents-python: A lightweight, powerful framework for multi-agent workflows, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
30. Agent as a Service (AaaS): A Comprehensive Guide : Aalpha, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
31. Multi-tenancy in AI Agentic Systems | by Isuru SIriwardana | Medium, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
32. Architectural Approaches for AI and Machine Learning in Multitenant Solutions, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
33. Top 7 Open Source AI Agent Frameworks for Building AI Agents - Adopt AI, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
34. LangChain vs LlamaIndex: A Detailed Comparison - DataCamp, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
35. Build an Agent - Install LangChain, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
36. Vertex AI Agent Builder | Google Cloud, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
37. How to create a dynamic (self-constructing) chain - Install LangChain, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
38. The developer-trusted framework for building context-aware AI agents - LlamaIndex, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
39. How to create agents with LlamaIndex | Online Courses, Learning Paths, and Certifications, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
40. Using Agents in LlamaIndex - Hugging Face Agents Course, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
41. Build LLamaIndex Agents with MCP Connector | by Pedro Azevedo - Medium, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
42. run-llama/llama_index: LlamaIndex is the leading framework for building LLM-powered agents over your data. - GitHub, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
43. agno-agi/agno: Multi-agent framework, runtime and control ... - GitHub, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
44. What is Agno? - Agno, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
45. Agno Framework: A Lightweight Library for Building Multimodal Agents - Analytics Vidhya, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
46. Agno: Building Multimodal AI Agents - GeeksforGeeks, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
47. AI Agents X : Agno — Agentic Framework | by DhanushKumar - Medium, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
48. Framework for orchestrating role-playing, autonomous AI agents. By fostering collaborative intelligence, CrewAI empowers agents to work together seamlessly, tackling complex tasks. - GitHub, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
49. agents — LangChain documentation, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
50. AI Agent Platform: Best Practices – Knowledge Base - Talkdesk Support, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
51. Technical Tuesday: 10 best practices for building reliable AI agents in 2025 - UiPath, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
52. What is Agentic RAG? Building Agents with Qdrant, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
53. How to add semantic search to your agent's memory - GitHub Pages, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
54. Writing effective tools for AI agents—using AI agents - Anthropic, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
55. Building Effective AI Agents - Anthropic, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
56. What is Agentic RAG? | IBM, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
57. confident-ai/deepteam: DeepTeam is a framework to red ... - GitHub, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
58. DeepTeam - The Open-Source LLM Red Teaming Framework, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
59. ai-red-team · GitHub Topics, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
60. PyRIT: A Framework for Security Risk Identification and Red Teaming in Generative AI Systems - arXiv, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
61. Azure/PyRIT: The Python Risk Identification Tool for ... - GitHub, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
62. Red Teaming AI: A closer look at PyRIT usage for security - CyberProof, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
63. PyRIT — PyRIT Documentation - Azure documentation, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
64. Run AI Red Teaming Agent Locally (Azure AI Evaluation SDK) - Microsoft Learn, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
65. Microsoft AI Red Tools: Securing the Future of AI with PyRIT and Advanced Risk Mitigation, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
66. Genez-io/genezio-deepteam: The LLM Red Teaming Framework - GitHub, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
67. Quick Introduction | DeepTeam - The Open-Source LLM Red Teaming Framework, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
68. Stanford Develops Real-World Benchmarks for Healthcare AI Agents, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
69. Better Benchmarks for Safety-Critical AI Applications | Stanford HAI, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
70. Stanford AI Safety, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
71. Artificial Intelligence Index Report 2025 | Stanford HAI, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
72. METR, дата последнего обращения: октября 29, 2025, [URL_REMOVED]
73. 2025 AI Safety Index - Future of Life Institute, дата последнего обращения: октября 29, 2025, [URL_REMOVED]