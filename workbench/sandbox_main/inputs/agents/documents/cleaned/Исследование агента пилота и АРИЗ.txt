Создание Автономного Пилот-Агента с Возможностью Изобретательского Решения Проблем: Архитектура, Планирование и Реализация на Платформе.NET




Часть I: Архитектурные Основы для Автономного Пилот-Агента


Разработка автономных систем искусственного интеллекта, способных не только выполнять задачи, но и творчески преодолевать непредвиденные препятствия, представляет собой передний край исследований в области ИИ. Создание "пилот-агента", который может анализировать задачи, выбирать оптимальные стратегии и, столкнувшись с неразрешимой проблемой, переключать свой фокус на изобретательский поиск нового решения, требует фундаментального переосмысления архитектурных принципов. В этой части закладывается теоретическая основа для такого агента, описываются ключевые принципы агентных систем, их когнитивная архитектура и модель практического мышления, которая позволяет формализовать переход от рутинного выполнения к творческому решению проблем.


1.1. Ключевые Принципы Агентных Систем: Автономность, Адаптивность и Целеустремленность


В основе любого продвинутого ИИ-агента лежит его архитектура — структурный план, определяющий, как интеллектуальная программная система воспринимает, обрабатывает и реагирует на свою среду.1 Эта архитектура является не просто набором компонентов, а целостной системой, работающей на основе фундаментальных принципов, которые и наделяют ее агентными свойствами. Для создания пилот-агента, способного к изобретательскому мышлению, эти принципы становятся не просто желательными, а обязательными предпосылками.
Ключевые принципы, формирующие основу агентной системы, включают 2:
1. Автономность (Autonomy): Это неотъемлемое свойство агента действовать независимо, без необходимости явных инструкций на каждом шагу. Автономность выходит далеко за рамки простой автоматизации; она подразумевает способность агента самостоятельно оценивать ситуации, принимать решения и предпринимать действия в реальном времени для достижения поставленных целей.2 Для пилот-агента это означает способность самостоятельно инициировать процесс анализа задачи, выбирать протоколы и, что наиболее важно, принимать решение о необходимости смены стратегии при столкновении с проблемой.
2. Адаптивность (Adaptability): Это способность агента корректировать свое поведение на основе новых данных, обратной связи или изменений в окружающей среде. Современные агентные архитектуры используют обучение с подкреплением или тонко настроенные модели, чтобы реагировать на контекстуальные сдвиги.2 Адаптивный агент не просто следует предопределенным путям; он учится на взаимодействиях и со временем развивает свои стратегии. Именно эта гибкость позволяет агенту понять, что текущий подход неэффективен, и инициировать поиск альтернативы.
3. Целеустремленность (Goal-Oriented Behavior): Интеллектуальный агент бесполезен, если он не стремится к конкретному результату. Целеустремленность гарантирует, что каждое действие агента служит достижению определенной цели, будь то выполнение задачи, оптимизация метрики или помощь пользователю.2 В хорошо структурированной агентной архитектуре цели могут быть многоуровневыми и динамичными. Агент должен уметь управлять краткосрочными задачами (например, вызов API), не теряя из виду долгосрочные цели (например, успешное завершение всего проекта).4
4. Непрерывное Обучение (Continuous Learning): В отличие от традиционных моделей ИИ, требующих периодического переобучения, агентные системы процветают, когда они спроектированы для непрерывного обучения. Это означает, что агенты обновляют свои знания на основе новых входных данных, совершенствуют свои стратегии через циклы обратной связи и со временем становятся более точными и эффективными.2
Эти четыре принципа в совокупности формируют основу для более сложных когнитивных функций, таких как предвидение, саморефлексия и самореактивность, которые являются неотъемлемыми атрибутами по-настоящему агентного поведения.3 Агент, построенный на этих принципах, перестает быть просто инструментом и становится проактивным участником процесса, способным не только следовать инструкциям, но и проявлять инициативу. Именно такая архитектурная основа позволяет реализовать сложную логику переключения фокуса, требуемую для пилот-агента, — переход от выполнения к изобретению.


1.2. Когнитивная Архитектура Агента: Четырехкомпонентная Модель


Для реализации вышеупомянутых принципов агентная система должна обладать сложной внутренней структурой, которую можно назвать когнитивной архитектурой. Эта архитектура представляет собой организацию "мозга" агента, определяющую, как он обрабатывает информацию и принимает решения. Современные исследования показывают, что наиболее эффективные архитектуры для автономных агентов состоят из четырех взаимосвязанных компонентов, образующих замкнутый когнитивный цикл.5
1. Модуль Восприятия (Perception Module): Этот компонент является "органами чувств" агента, через которые он воспринимает и интерпретирует свою среду. Модуль восприятия преобразует необработанные данные — текст, аудио, визуальную информацию, показания датчиков или ответы API — в структурированную информацию, с которой могут работать другие модули.2 Этот процесс включает в себя интеграцию данных из нескольких источников, их предварительную обработку для удаления шума и извлечение ключевых признаков.1 Качество и точность этого модуля напрямую влияют на релевантность и своевременность автономных решений.
2. Когнитивный Модуль / Модуль Планирования (Cognitive/Planning Module): Это ядро или "мозг" агента, отвечающий за задачи высокого уровня, такие как рассуждение, принятие решений и планирование.1 Получив структурированную информацию от модуля восприятия, когнитивный модуль использует механизмы принятия решений для оценки вариантов и выбора соответствующих действий на основе текущей информации и целей. Здесь происходит декомпозиция сложных задач на более мелкие и управляемые подзадачи.6 Именно в этом модуле будет реализована основная логика пилот-агента: как стандартное планирование выполнения, так и запуск протокола АРИЗ при обнаружении неразрешимой проблемы.
3. Модуль Памяти (Memory Module): Подобно человеку, агент нуждается в памяти для хранения информации и обучения на основе опыта. Память является банком знаний агента и критически важна для принятия обоснованных решений.4 Архитектура памяти обычно делится на два типа:
   * Краткосрочная память: Содержит информацию о текущем контексте и непосредственном фокусе агента. Она используется для отслеживания состояния текущей задачи и недавних взаимодействий.4
   * Долгосрочная память: Хранит накопленные знания, прошлый опыт и изученные стратегии. Агент может обращаться к этой памяти, чтобы принимать более эффективные решения в будущем.4
Для пилот-агента модуль памяти имеет решающее значение для сохранения состояния многоэтапного процесса решения проблемы, особенно во время выполнения сложного алгоритма АРИЗ.
   4. Модуль Действий (Action Module): Этот компонент отвечает за претворение решений агента в жизнь. Он управляет физическими или виртуальными исполнительными механизмами (актюаторами), такими как вызовы API, выполнение кода или управление роботизированными системами.1 Модуль действий также включает механизмы обратной связи, которые отслеживают результаты выполненных действий и передают эту информацию обратно в модуль восприятия, замыкая когнитивный цикл. Это позволяет агенту оценивать успешность своих действий и корректировать дальнейшее поведение.1
Эта четырехкомпонентная модель обеспечивает необходимую структуру для создания пилот-агента. Модуль восприятия собирает данные о задаче и среде, когнитивный модуль анализирует их и строит план, модуль памяти предоставляет контекст и знания, а модуль действий выполняет план. Сбой в этом цикле, обнаруженный через обратную связь, становится триггером для активации более сложных процессов в когнитивном модуле.


1.3. Модель "Вера-Желание-Намерение" (BDI): Основа для Практического Мышления


Хотя четырехкомпонентная модель описывает что делает агент, она не полностью объясняет почему он принимает те или иные решения, особенно когда речь идет о сложных когнитивных сдвигах, таких как переход от выполнения к изобретению. Для моделирования этого процесса практического мышления идеально подходит программная модель "Вера-Желание-Намерение" (Belief-Desire-Intention, BDI).8 Эта модель, основанная на философской теории Майкла Братмана, обеспечивает механизм для разделения деятельности по выбору плана (обдумывание того, что делать) и выполнения текущих активных планов (выполнение этого).8
Архитектура BDI строится на трех ключевых ментальных установках 8:
   * Веры (Beliefs): Представляют собой информационное состояние агента — его представления о мире, включая самого себя и других агентов. Важно, что веры не обязательно являются истинным знанием; они могут быть неполными или даже ложными и могут меняться со временем. Веры хранятся в базе знаний, или "наборе вер" (belief set).
   * Желания (Desires): Представляют мотивационное состояние агента. Это цели или ситуации, которых агент хотел бы достичь. Желания могут быть противоречивыми (например, "пойти на вечеринку" и "остаться дома"). Когда желание выбирается для активного преследования, оно становится целью (Goal), при этом набор активных целей должен быть непротиворечивым.
   * Намерения (Intentions): Представляют собой совещательное состояние агента — то, что агент решил сделать. Намерения — это желания, которым агент в определенной степени привержен. В реализованных системах это означает, что агент начал выполнять план (Plan) — последовательность действий для достижения одного или нескольких своих намерений.
Кроме того, в модели BDI важную роль играют События (Events) — триггеры для реактивной деятельности агента. Событие может обновить веры, запустить планы или изменить цели.8
Именно цикл BDI обеспечивает формальную когнитивную основу для объяснения того, как и почему пилот-агент переключает свой фокус при столкновении с проблемой. Этот процесс можно описать следующей логической цепочкой:
   1. Стандартное Выполнение: Агент начинает работу с намерением выполнить задачу, следуя определенному плану (например, плану, сгенерированному с помощью парадигмы ReAct).
   2. Возникновение Проблемы: В процессе выполнения агент сталкивается с препятствием. Попытки его преодолеть стандартными методами (например, повторные вызовы API, незначительные корректировки плана) раз за разом терпят неудачу.
   3. Обновление Вер: Обратная связь от модуля действий генерирует серию событий (например, "ошибка API", "отсутствие прогресса"). Эти события обновляют веры агента. Изначальная вера "План П приведет к цели Ц" сменяется новой, более сильной верой: "Вера: Текущий план П неэффективен для достижения цели Ц в текущих условиях".
   4. Формирование Когнитивного Тупика: Новая вера вступает в конфликт с текущим намерением продолжать выполнение плана П. Это состояние, когда агент осознает невозможность прогресса с помощью текущей стратегии, можно определить как "Когнитивный Тупик".
   5. Генерация Нового Желания: Когнитивный тупик порождает новое, мета-уровневое желание: "Желание: Найти принципиально иной способ достижения цели Ц". Это желание имеет более высокий приоритет, чем простое следование старому плану.
   6. Формирование Нового Намерения: В процессе обдумывания (deliberation) агент принимает это новое желание и обязуется его выполнить, формируя новое намерение: "Намерение: Активировать протокол АРИЗ для переосмысления проблемы и генерации нового, инновационного плана".
Таким образом, модель BDI превращает смену фокуса из жестко закодированного правила if (error) then (run_ariz) в осмысленный, управляемый внутренним состоянием когнитивный процесс. Агент не просто реагирует на ошибку — он осознает неудачу своей стратегии, формирует новую цель по поиску решения и целенаправленно запускает специализированный механизм для ее достижения. Эта модель напрямую связывает архитектуру агента с его способностью к адаптивному и изобретательскому поведению, что является ядром концепции пилот-агента.


Часть II: Динамическое Управление Задачами и Адаптивное Планирование


Прежде чем агент сможет применить изобретательский подход к решению проблемы, он должен обладать сложной системой для выполнения задач в "нормальном" режиме. Эта система должна включать в себя возможности для анализа входящих задач, динамического планирования своих действий и, что самое важное, распознавания момента, когда стандартные методы исчерпали себя. Этот раздел описывает операционный цикл пилот-агента — от получения задачи до момента осознания когнитивного тупика, который служит катализатором для активации протокола АРИЗ.


2.1. Фаза 1: Проактивный Анализ Задачи и Выбор Протокола


Работа пилот-агента начинается не с немедленного выполнения, а с проактивной фазы анализа. Получив высокоуровневую цель от пользователя, агент первым делом должен провести декомпозицию задачи (task decomposition).6 Этот процесс, управляемый его когнитивным модулем, разбивает сложную цель на иерархию более мелких, управляемых подзадач. Например, задача "спланировать командировку" будет декомпозирована на подзадачи: "забронировать авиабилеты", "найти отель", "составить расписание встреч".7
После декомпозиции агент оценивает сложность каждой подзадачи и всей задачи в целом. Эта оценка основывается на нескольких факторах, таких как глубина планирования, необходимая для решения, требуемая способность к обучению, уровень неопределенности в среде и необходимость координации с другими системами.11 Понимание сложности позволяет агенту классифицировать себя и задачу в рамках установленной таксономии, что помогает выбрать наиболее подходящие внутренние настройки и протоколы для выполнения.
Для систематизации этого процесса можно использовать классификацию типов ИИ-агентов, которая ранжирует их по возрастанию сложности.
Таблица 1: Сравнительный анализ типов ИИ-агентов 11
Тип агента
	Уровень сложности
	Ключевые черты
	Глубина планирования
	Обработка неопределенности
	1. Функциональные
	Очень низкий
	Детерминированная интеграция с внешними системами (API, устройства).
	Отсутствует.
	Не справляется с неопределенностью.
	2. Простые рефлекторные
	Низкий
	Реагируют на текущие входные данные на основе правил "если-то".
	Отсутствует.
	Не могут обрабатывать неполные данные.
	3. Модельно-ориентированные
	Низко-средний
	Поддерживают внутреннюю модель мира для обработки частичной наблюдаемости.
	Отсутствует.
	Справляются с частичной наблюдаемостью.
	4. Целеориентированные
	Средний
	Планируют последовательности действий для достижения конкретных целей.
	Планируют будущие состояния.
	Ограниченно; предполагают определенные цели.
	5. Обучающиеся
	Средне-высокий
	Адаптируются и улучшают производительность на основе опыта и обратной связи.
	Улучшают планы со временем.
	Эффективны в меняющихся средах.
	6. Утилитарные
	Высокий
	Максимизируют "полезность", балансируя компромиссы (стоимость, время, риск).
	Планируют на основе многоцелевой оценки.
	Справляются с конкурирующими приоритетами.
	7. Иерархические
	Высокий
	Многоуровневая структура для декомпозиции задач (стратегия/тактика).
	Многоуровневое планирование.
	Управляют сложными, многоэтапными проблемами.
	8. Многоагентные системы
	Очень высокий
	Множество агентов сотрудничают или конкурируют для достижения общей цели.
	Возникает из взаимодействия агентов.
	Справляются с распределенными, неопределенными средами.
	Пилот-агент, описанный в запросе, является гибридом Обучающегося, Утилитарного и Иерархического агентов. Он должен обучаться на своем опыте, принимать решения с учетом компромиссов и декомпозировать сложные задачи. Осознание своего места в этой иерархии позволяет агенту на этапе анализа выбрать соответствующие протоколы связи и инструменты.12 Например, для простой задачи извлечения данных он может выбрать легковесный протокол и один инструмент, а для сложной задачи, требующей координации, — более надежный протокол и набор взаимосвязанных инструментов.


2.2. Динамическое Планирование и Выполнение: Цикл "Мышление-Действие-Наблюдение"


После анализа и выбора начальной стратегии агент переходит к фазе выполнения, которая носит итеративный и динамический характер. Вместо того чтобы слепо выполнять заранее составленный план, агент работает в цикле, который лучше всего описывается парадигмой ReAct (Reasoning and Action).6 Эта парадигма предполагает чередование шагов рассуждения (мышления) с шагами выполнения (действия), что позволяет агенту постоянно адаптироваться к меняющейся обстановке.
Этот цикл можно представить как последовательность "Мышление-Действие-Наблюдение":
   1. Мышление (Think): Агент анализирует текущее состояние, свою цель и доступные инструменты, чтобы решить, какое действие предпринять следующим. Этот шаг включает в себя вербализацию рассуждений, что дает представление о процессе принятия решений агентом.6
   2. Действие (Act): Агент выполняет выбранное действие. Чаще всего это вызов инструмента (tool calling) — обращение к внешнему API, базе данных, выполнение фрагмента кода или использование другого сервиса.6 Для эффективного выполнения этого шага агент должен обладать способностью к динамической маршрутизации инструментов.15 Это означает, что агент не привязан к фиксированному набору инструментов, а может в реальном времени выбирать наиболее подходящий инструмент из Реестра инструментов (Tool Registry) на основе контекста, типа данных и истории производительности.
   3. Наблюдение (Observe): Агент получает результат выполненного действия (например, ответ от API или изменение в среде) и анализирует его. Эта новая информация поступает в модуль восприятия и обновляет "веры" агента о текущем состоянии мира.
Этот цикл повторяется до тех пор, пока задача не будет выполнена. Ключевым элементом здесь является постоянная самокоррекция: на каждом шаге "Наблюдение" агент оценивает, приблизился ли он к цели, и на шаге "Мышление" корректирует свой план.6 Этот итеративный процесс является стандартным рабочим режимом пилот-агента. Однако именно на шаге "Наблюдение" агент собирает данные, которые в конечном итоге могут указать на то, что стандартный цикл ReAct больше не приводит к прогрессу.


2.3. Обнаружение Сбоев и Резервное Планирование: Распознавание "Когнитивного Тупика"


Способность агента действовать в реальном мире сопряжена с рисками. Сбои могут принимать различные формы: от очевидных ошибок, таких как сбой API, до более тонких проблем, таких как зацикливание, раскоординация в многоагентных системах или каскадные ошибки, вызванные "галлюцинациями" модели.16 Поэтому для любого агента, который выполняет действия, а не просто генерирует текст, абсолютно необходимо наличие системы обнаружения сбоев в реальном времени.17
Надежность этой системы обнаружения должна быть откалибрована в зависимости от трех ключевых факторов 17:
   * Ставки (Stakes): Насколько критичны последствия ошибки? Действия с высокими ставками (например, финансовые транзакции, изменение критического кода) требуют более надежного контроля.
   * Обратимость (Reversibility): Насколько легко можно отменить действие в случае сбоя? Необратимые действия (например, удаление данных, отправка сообщений) требуют превентивного обнаружения сбоев.
   * Возможности (Affordances): Насколько широки полномочия агента? Агенты с постоянной памятью и динамическим выбором инструментов могут вызывать сбои более тонкими и каскадными способами, что требует многоуровневых механизмов обнаружения.
Для пилот-агента простой обработки ошибок недостаточно. Ему необходимо распознать состояние, когда он не просто столкнулся с единичной ошибкой, а попал в "Когнитивный Тупик" — ситуацию, в которой его текущая стратегия планирования в принципе не способна привести к решению. Это состояние можно формализовать и определить как триггер для запуска резервного плана (contingency plan), которым в данном случае является протокол АРИЗ.19
Когнитивный тупик может быть определен через набор измеримых условий, отслеживаемых агентом в ходе его операционного цикла 21:
   * Повторение Состояния (State Repetition): Внутреннее состояние агента или состояние среды повторяется $N$ раз подряд. Это явный признак зацикливания.
   * Частота Сбоев Инструмента (Tool Failure Rate): Конкретный инструмент или API возвращает ошибку $M$ раз подряд при попытке решить одну и ту же подзадачу. Это указывает на то, что выбранный инструмент не подходит для текущего контекста.
   * Плато Уверенности (Confidence Score Plateau): Внутренняя оценка уверенности агента в успехе текущего плана остается ниже порогового значения в течение $K$ последовательных шагов.
   * Стагнация Метрики Прогресса (Progress Metric Stagnation): Количественный показатель прогресса в достижении цели (например, количество написанных строк кода, процент выполненных подзадач) не улучшается на протяжении $L$ итераций цикла.
Когда одно или несколько из этих условий выполняются, система обнаружения сбоев фиксирует Когнитивный тупик. Это событие, в терминах BDI, обновляет веру агента в неэффективность текущего намерения. Вместо того чтобы просто повторить попытку или запросить помощь человека, агент активирует свой основной резервный план: он останавливает цикл "Мышление-Действие-Наблюдение" и инициирует мета-процесс изобретательского решения проблемы на основе АРИЗ. Таким образом, переход от выполнения к изобретению становится детерминированным, наблюдаемым и управляемым поведением агента.


Часть III: Протокол АРИЗ для Изобретательского Переосмысления Проблемы


Когда стандартные методы планирования и выполнения приводят пилот-агента в когнитивный тупик, активируется его самая мощная и уникальная способность — переход к структурированному изобретательскому мышлению. Этот процесс основан не на случайном переборе вариантов, а на строгой методологии, разработанной для решения самых сложных инженерных и творческих задач. В основе этого механизма лежит Теория Решения Изобретательских Задач (ТРИЗ) и ее центральный инструмент — Алгоритм Решения Изобретательских Задач (АРИЗ). Этот раздел раскрывает, как эта ориентированная на человека методология может быть адаптирована и формализована для использования искусственным интеллектом, чтобы обеспечить качественный скачок в решении проблем.


3.1. Введение в ТРИЗ: Систематический Подход к Инновациям


Теория Решения Изобретательских Задач (ТРИЗ) — это методология, созданная Генрихом Альтшуллером на основе анализа десятков тысяч патентов по всему миру.22 Основная идея ТРИЗ заключается в том, что существуют объективные закономерности развития технических систем и универсальные принципы для решения изобретательских задач. Вместо того чтобы полагаться на интуицию, метод проб и ошибок или мозговой штурм, ТРИЗ предлагает систематический и логический подход к инновациям.23
Центральным понятием в ТРИЗ является противоречие. ТРИЗ утверждает, что в основе любой сложной проблемы лежит одно или несколько противоречий, и изобретательское решение — это не компромисс, а способ полного устранения этого противоречия.23 Например, в автомобилестроении классическое противоречие: "увеличение мощности двигателя (улучшающий параметр) приводит к увеличению расхода топлива (ухудшающийся параметр)". Компромиссное решение — это двигатель со средней мощностью и средним расходом. Изобретательское решение — это, например, гибридный двигатель, который обеспечивает высокую мощность при низком расходе.
Для выявления и разрешения противоречий ТРИЗ предлагает набор мощных инструментов, включая:
   * 40 Изобретательских Принципов: Обобщенные приемы, которые наиболее часто встречаются в патентах и используются для разрешения технических противоречий.
   * Матрица Противоречий: Таблица, которая связывает стандартные технические параметры (например, "Вес", "Скорость", "Прочность") и рекомендует наиболее вероятные изобретательские принципы для разрешения конфликта между ними.24
   * Анализ Вещественно-Полевых Ресурсов (Веполь): Метод моделирования системы для выявления неэффективных или вредных взаимодействий.26
Для пилот-агента ТРИЗ служит "мета-эвристикой" для решения проблем. Если стандартный цикл ReAct отвечает на вопрос "как сделать следующий шаг?", то ТРИЗ и АРИЗ отвечают на вопрос "как по-другому подумать обо всей последовательности шагов?". Это фундаментальный сдвиг от тактического выполнения к стратегическому переосмыслению.


3.2. АРИЗ: Алгоритмический Двигатель для Разрешения Противоречий


Если ТРИЗ — это общая теория, то Алгоритм Решения Изобретательских Задач (АРИЗ) — это ее главный практический инструмент. АРИЗ представляет собой строгий, пошаговый, логический процесс, предназначенный для решения самых сложных, нестандартных и запутанных проблем, которые не поддаются решению с помощью других, более простых инструментов ТРИЗ.27
АРИЗ — это не простая формула, а сложная программа, состоящая из множества шагов (в классической версии АРИЗ-85В их более 50, сгруппированных в 9 частей), которая направляет мышление решателя от первоначального, расплывчатого описания проблемы к четкой физической сути конфликта и, в конечном итоге, к сильному, изобретательскому решению.27 Важнейшая особенность АРИЗ заключается в том, что более 50% алгоритма посвящено не поиску решения, а переформулированию проблемы.28 Алгоритм заставляет решателя посмотреть на проблему с разных сторон, абстрагироваться от привычных терминов и выявить ее глубинную суть.
Ключевые концепции, используемые в АРИЗ:
   * Идеальный Конечный Результат (ИКР): Это формулировка идеального решения, свободного от ограничений и недостатков существующей системы. ИКР описывает ситуацию, когда требуемая функция выполняется сама по себе, без затрат, усложнений и вредных эффектов.25 Например, для проблемы износа трубы ИКР может звучать так: "Труба не изнашивается, потому что она сама себя защищает".
   * Техническое Противоречие (ТП): Возникает, когда попытка улучшить один параметр системы (например, скорость транспортировки) приводит к ухудшению другого (например, износ оборудования).28
   * Физическое Противоречие (ФП): Возникает, когда к одному и тому же элементу системы или его параметру предъявляются противоположные, взаимоисключающие физические требования (например, колено трубы должно быть твердым, чтобы противостоять ударам, и одновременно мягким, чтобы не повреждать транспортируемые детали).27 Выявление и разрешение ФП является сердцем АРИЗ.
   * Ресурсы Системы: АРИЗ требует тщательного анализа и мобилизации всех доступных ресурсов — веществ, полей, времени, пространства, как внутри системы, так и в ее надсистеме и окружающей среде — для решения проблемы.28
Адаптация АРИЗ для ИИ-агента представляет собой серьезную проблему, поскольку алгоритм был разработан для человеческого мышления и требует абстрактного, творческого подхода.27 Однако последние исследования показывают, что большие языковые модели (LLM) можно успешно направлять через этапы ТРИЗ с помощью тщательно разработанных рабочих процессов и промптов.32 Были даже созданы многоагентные системы, в которых каждый агент выполняет определенную роль в процессе ТРИЗ.36
Это позволяет нам формализовать АРИЗ как структурированную цепочку промптов, управляемую специализированным плагином агента. Вместо того чтобы пытаться закодировать логику АРИЗ напрямую, агент будет использовать LLM как мощный "двигатель рассуждений", направляя его через ключевые этапы алгоритма.
Пример такого рабочего процесса, управляемого ARIZContingencyPlugin:
   1. Шаг 1 (Анализ Системы и Проблемы): Плагин, получив описание проблемы и неудачного плана, отправляет LLM первый промпт:
"Вы — эксперт по ТРИЗ. Текущая проблема: [описание]. Неудачный план: [описание]. Проанализируйте эту систему. Определите ее основную полезную функцию, вредные функции, компоненты и надсистему. Структурируйте ответ в формате JSON с ключами: 'primary_function', 'harmful_functions', 'components'."
   2. Шаг 2 (Формулирование Технического Противоречия): Плагин парсит полученный JSON и формирует следующий промпт:
"На основе предыдущего анализа сформулируйте ключевое Техническое Противоречие. Определите улучшаемый и ухудшаемый параметры из списка 39 стандартных параметров ТРИЗ. Выведите JSON с ключами: 'improving_param', 'worsening_param'."
   3. Шаг 3 (Поиск Изобретательских Принципов): Используя идентифицированные параметры, плагин обращается к локальной, заранее подготовленной Матрице Противоречий (представленной в виде таблицы или словаря) и извлекает рекомендованные номера изобретательских принципов.
   4. Шаг 4 (Генерация Нового Плана): Плагин отправляет финальный промпт, который инициирует творческий синтез:
"Выявленное противоречие может быть разрешено с помощью следующих принципов ТРИЗ: [Принцип А, Принцип Б]. Сгенерируйте новый, высокоуровневый план для достижения исходной цели [цель], применяя один или несколько из этих принципов к проблеме. Новый план должен кардинально отличаться от предыдущего неудачного плана и устранять выявленное противоречие."
Этот подход превращает АРИЗ из абстрактной человеческой методологии в вычислительно выполнимый, управляемый состоянием процесс. Он использует сильные стороны LLM (обширные знания и способность к рассуждению), но заключает их в жесткие рамки алгоритма, что обеспечивает систематичность и целенаправленность поиска решения. Это и есть центральная инновация предлагаемого пилот-агента.


3.3. 40 Изобретательских Принципов как Эвристическая Библиотека для Генерации Планов


40 изобретательских принципов являются результатом анализа тысяч изобретений и представляют собой обобщенные стратегии для разрешения технических противоречий.23 Принципы, такие как "Дробление", "Вынесение", "Предварительное действие", "Асимметрия" или "Матрешка", являются абстрактными, но чрезвычайно мощными эвристиками.
В контексте пилот-агента эти 40 принципов служат не просто списком для справки, а библиотекой "когнитивных сдвигов". Когда на шаге 3 процесса АРИЗ агент определяет, что для решения его противоречия рекомендуются, например, принципы "Дробление" и "Динамичность", эти рекомендации становятся мощными указаниями для LLM на шаге 4. Промпт, содержащий эти принципы, заставляет модель генерировать план, который будет соответствовать этим эвристикам, тем самым принудительно выводя ее из "колеи" предыдущего, неудачного способа мышления. Это гарантирует, что новый план будет не просто незначительной модификацией старого, а качественно иным подходом к проблеме, что и является основной целью изобретательского процесса.
Ниже приведена таблица, иллюстрирующая, как некоторые из этих абстрактных принципов могут быть транслированы в конкретные стратегии для ИИ-агента.
Таблица 2: 40 Изобретательских Принципов ТРИЗ и их Применение для ИИ-агентов (Примеры)
Принцип
	Описание
	Потенциальное применение для ИИ-агента
	1. Дробление (Segmentation)
	Разделить объект или систему на независимые части; сделать объект разборным.
	Вместо обработки большого файла целиком, разбить его на части и обрабатывать параллельно или с помощью специализированных субагентов. Декомпозировать монолитную задачу на последовательность микрозадач.
	7. "Матрешка" (Nested Doll)
	Поместить один объект внутрь другого; один объект проходит сквозь полость в другом.
	Создать иерархическую структуру данных или планов, где подпланы вложены в планы более высокого уровня. Использовать инкапсуляцию для изоляции компонентов агента.
	9. Предварительное анти-действие (Preliminary Anti-action)
	Заранее выполнить действие с вредными последствиями, чтобы контролировать их.
	Перед выполнением потенциально опасной операции (например, удаление данных) создать резервную копию или "снимок" состояния системы (принцип "заранее подстелить соломку").
	10. Предварительное действие (Preliminary Action)
	Заранее выполнить требуемое действие (полностью или частично).
	Предварительно кэшировать часто запрашиваемые данные. Провести предварительную валидацию входных данных перед запуском ресурсоемкого процесса.
	15. Динамичность (Dynamism)
	Характеристики объекта или среды должны изменяться для оптимальной работы на каждом этапе.
	Динамически изменять параметры (например, количество используемых потоков, таймауты API) в зависимости от текущей нагрузки или производительности системы. Адаптивно выбирать инструменты.
	19. Периодическое действие (Periodic Action)
	Перейти от непрерывного действия к периодическому (импульсному).
	Вместо постоянного опроса API на наличие обновлений, перейти на использование веб-хуков или опрашивать с экспоненциальной задержкой.
	28. Замена механической схемы (Mechanical Substitution)
	Заменить механическую систему на оптическую, акустическую, тепловую, обонятельную.
	Вместо анализа структурированных логов (текст), использовать визуализацию данных (оптика) для поиска аномалий. Использовать обработку естественного языка для анализа неструктурированных отчетов.
	Эта таблица служит практическим мостом между теорией ТРИЗ и модулем планирования действий агента. Она преобразует абстрактные концепции в конкретные, реализуемые вычислительные стратегии, предоставляя разработчикам как руководство, так и источник вдохновения для расширения возможностей агента.


Часть IV: План Реализации в Visual Studio с Использованием.NET


Переход от теоретических концепций к работающему прототипу требует выбора правильных инструментов и четкого плана реализации. Этот раздел представляет собой практическое руководство для разработчиков по созданию пилот-агента в среде Visual Studio с использованием языка C# и экосистемы.NET. Основное внимание уделяется выбору подходящего фреймворка, построению архитектуры агента и реализации ключевой логики смены фокуса на основе АРИЗ.


4.1. Выбор Подходящего Фреймворка: Semantic Kernel vs. AutoGen для.NET


Экосистема.NET предлагает несколько мощных фреймворков для создания агентных ИИ-приложений. Выбор правильного фреймворка является критически важным архитектурным решением, которое определит структуру и возможности будущего агента.
      * Microsoft Semantic Kernel: Это SDK, разработанный для интеграции моделей ИИ в приложения. Его центральной концепцией является Kernel (Ядро), которое выступает в роли оркестратора, управляющего Plugins (Плагинами) — наборами функций, доступных для вызова моделью ИИ. Semantic Kernel обладает сильной поддержкой для управления памятью, планирования и вызова функций (function calling), что делает его идеальным для создания сложных одноагентных систем.40 Его современный подход к планированию основан на нативной поддержке вызова функций моделями OpenAI, что упрощает создание динамических планов выполнения.43
      * AutoGen для.NET: Это фреймворк, изначально разработанный для Python и портированный на.NET, который специализируется на создании многоагентных приложений. Его основные концепции — это взаимодействующие агенты (AgentChat), которые обмениваются асинхронными сообщениями для совместного решения сложных задач.44
      * Microsoft Agent Framework: Это новый, развивающийся фреймворк, который стремится объединить сильные стороны Semantic Kernel (надежность, типобезопасность, расширяемость) и AutoGen (простые абстракции для многоагентных паттернов).46
Рекомендация: Для реализации концепции "пилот-агента", который действует как единая сущность, но с различными внутренними режимами работы, Microsoft Semantic Kernel является наиболее подходящим выбором. Его архитектура Kernel + Plugins позволяет элегантно инкапсулировать стандартную логику выполнения и протокол АРИЗ в виде отдельных, но взаимосвязанных плагинов. AutoGen станет логичным следующим шагом, если потребуется расширить систему до многоагентной "команды по инновациям", где разные агенты (например, "Инженер", "Специалист по ТРИЗ", "Менеджер проекта") будут сотрудничать в рамках процесса АРИЗ.36
Таблица 3: Сравнение Функциональности Фреймворков.NET для Агентов
Характеристика
	Microsoft Semantic Kernel
	AutoGen для.NET
	Основная абстракция
	Kernel (Ядро) как оркестратор Plugins (Плагинов).
	Agent (Агент) как участник AgentChat (Чата агентов).
	Основной сценарий
	Создание сложных одноагентных систем и интеграция ИИ в приложения.
	Создание многоагентных систем для совместного решения задач.
	Управление состоянием
	Управление состоянием на уровне потока (thread-based), встроенные механизмы памяти.
	Управление состоянием через историю сообщений в чате.
	Планирование
	Мощные встроенные планировщики, основанные на автоматическом вызове функций (function calling).
	Планирование возникает из диалога и координации между агентами.
	Интеграция инструментов
	Через Plugins с нативными функциями C#, описанными для ИИ.
	Инструменты регистрируются для отдельных агентов.
	Этот сравнительный анализ показывает, что для создания единого агента со сложной внутренней логикой и динамическим планированием Semantic Kernel предоставляет более зрелую и подходящую архитектуру.


4.2. Создание Ядра Агента на C# с Помощью Semantic Kernel


Ниже приведен пошаговый процесс создания базовой структуры агента в.NET-проекте.
      1. Настройка Проекта в Visual Studio:
      * Создайте новое консольное приложение.NET: dotnet new console -n PilotAgent.
      * Установите необходимые NuGet-пакеты:
Bash
dotnet add package Microsoft.SemanticKernel
dotnet add package Microsoft.SemanticKernel.Connectors.OpenAI

Эти пакеты предоставляют ядро Semantic Kernel и коннектор для моделей OpenAI (включая Azure OpenAI).41
         2. Инициализация Ядра (Kernel):
В файле Program.cs создайте и сконфигурируйте экземпляр Kernel. Ядро будет управлять всеми плагинами и сервисами.
C#
using Microsoft.SemanticKernel;

// Создаем KernelBuilder
var builder = Kernel.CreateBuilder();

// Добавляем сервис для работы с чат-моделью (например, Azure OpenAI)
builder.Services.AddAzureOpenAIChatCompletion(
   "your-deployment-name",    // Название вашей модели в Azure
   "[URL_REMOVED]", // Endpoint вашего сервиса
   "your-api-key"             // API ключ
);

// Собираем ядро
Kernel kernel = builder.Build();

Этот код создает ядро и подключает его к сервису LLM, который будет выполнять функции рассуждения.41
         3. Архитектура на Основе Плагинов:
Вся функциональность агента инкапсулируется в плагины. Плагин — это обычный C#-класс, методы которого помечены специальными атрибутами, чтобы ядро могло их "видеть" и предлагать LLM для вызова.
C#
using Microsoft.SemanticKernel;
using System.ComponentModel;

public class StandardExecutionPlugin
{

   public async Task<string> ReadFileInChunksAsync(
       string filePath)
   {
       // Логика чтения файла по частям
       //...
       return "First chunk of file content...";
   }


   public async Task<string> AnalyzeChunkAsync(
       string textChunk)
   {
       // Логика анализа текста
       //...
       return "No anomalies found in this chunk.";
   }
}

Атрибут [KernelFunction] делает метод доступным для ядра, а `` предоставляет текстовое описание, которое LLM использует, чтобы понять, что делает функция и какие у нее параметры. Это критически важно для автоматического планирования.51


4.3. Реализация Смены Фокуса на Основе АРИЗ: Практическое Руководство


Это ядро функциональности пилот-агента. Реализация будет состоять из специального плагина для АРИЗ и логики, которая его активирует.
            1. Создание ARIZContingencyPlugin:
Этот плагин будет управлять состоянием процесса АРИЗ и содержать методы для каждого шага, реализованные как структурированные промпты.
C#
public class ARIZContingencyPlugin
{

   public async Task<string> Step1_AnalyzeSystemAsync(
       Kernel kernel,
       string problemContext)
   {
       string prompt = $"""
       You are a TRIZ expert. The current problem is: {problemContext}.
       Analyze this system. Identify its primary useful function, harmful functions, components, and environment.
       Structure your output as a JSON object with keys: 'primary_function', 'harmful_functions', 'components'.
       """;
       var result = await kernel.InvokePromptAsync(prompt);
       return result.ToString();
   }

   //... другие методы для шагов АРИЗ (Step2_FormulateContradiction, etc.)
}

Каждый метод инкапсулирует один шаг АРИЗ, вызывая LLM с высокоструктурированным промптом и ожидая структурированный ответ (предпочтительно JSON) для передачи на следующий шаг.
            2. Запуск Смены Фокуса с Помощью Динамического Планирования:
Semantic Kernel использует механизм автоматического вызова функций (automatic function calling) для динамического планирования. Мы настраиваем ядро так, чтобы оно само решало, какие функции из плагинов вызывать для достижения цели пользователя.43
C#
using Microsoft.SemanticKernel.Connectors.OpenAI;

//... инициализация ядра и добавление плагинов
kernel.Plugins.AddFromType<StandardExecutionPlugin>();
kernel.Plugins.AddFromType<ARIZContingencyPlugin>();

// Настройки для автоматического вызова функций
var executionSettings = new OpenAIPromptExecutionSettings
{
   ToolCallBehavior = ToolCallBehavior.AutoInvokeKernelFunctions
};

var chatHistory = new ChatHistory();
chatHistory.AddSystemMessage("You are an autonomous pilot agent. Your goal is to solve the user's request. If you get stuck, you must use the ARIZContingencyPlugin to find a new approach.");

// Основной цикл агента
while (true)
{
   //... получение ввода от пользователя
   //... вызов LLM с chatHistory и executionSettings

   // Логика обнаружения "Когнитивного Тупика"
   if (IsStuck(agentState))
   {
       chatHistory.AddSystemMessage("Standard approach failed. Initiating inventive problem-solving protocol using ARIZ.");
       // Следующий вызов LLM будет с большей вероятностью использовать ARIZContingencyPlugin
   }
}

Когда функция IsStuck() (реализующая логику из раздела 2.3) возвращает true, мы добавляем в историю чата системное сообщение. Это сообщение изменяет контекст для LLM, направляя его планировщик на использование функций из ARIZContingencyPlugin для следующего шага.
            3. Обработка Ошибок:
При создании сложных агентных систем важно предусмотреть надежную обработку ошибок. Это включает в себя обработку исключений от API, таймаутов и неожиданных ответов от LLM. Проблемы, такие как неправильный порядок сообщений при параллельных вызовах инструментов 54 или ошибки усечения данных 55, должны быть учтены при проектировании для обеспечения отказоустойчивости агента.


4.4. Инструкции для Консоли и Пример Кода для Пилот-Агента


Для демонстрации работы пилот-агента будет предоставлен репозиторий с готовым к запуску проектом.
Инструкции по запуску:
               1. Клонируйте репозиторий с [GitHub Link].
               2. Откройте решение PilotAgent.sln в Visual Studio 2022 или новее.
               3. В файле appsettings.json укажите ваши учетные данные для Azure OpenAI (endpoint, api-key, deployment-name).
               4. Установите точку останова в методе Step1_AnalyzeSystemAsync класса ARIZContingencyPlugin.cs, чтобы наблюдать за переходом в режим изобретательского решения.
               5. Запустите проект (F5 или dotnet run).
               6. В консоли введите начальный запрос, моделирующий сложную задачу с неочевидным решением. Например:
"Проанализируй приложенный лог-файл размером 10 ГБ и определи первопричину каскадного сбоя. Прямое чтение файла в память вызывает ошибку OutOfMemoryException."
               7. Наблюдаемый процесс:
                  * Попытка 1 (Неудача): Агент попытается использовать StandardExecutionPlugin.ReadFileInChunksAsync, но может зациклиться или не найти причину, так как сбой распределен по всему файлу.
                  * Обнаружение Тупика: После нескольких неудачных попыток анализа чанков метрика прогресса не изменится, что приведет к срабатыванию триггера Когнитивного тупика.
                  * Активация АРИЗ: В консоли появится сообщение о запуске протокола АРИЗ. Выполнение остановится на точке останова.
                  * Генерация Нового Плана: После выполнения шагов АРИЗ агент сгенерирует принципиально новый план, основанный, например, на принципе "Дробление" или "Предварительное действие":
"Новый план: Вместо последовательного чтения файла, я применю бинарный поиск по временным меткам в файле, чтобы быстро локализовать область каскадного сбоя. Затем я прочитаю только небольшой фрагмент данных (100 МБ) вокруг этой временной метки для детального анализа."
Этот пример наглядно демонстрирует переход от неэффективного линейного подхода к более изобретательному и эффективному решению, который стал возможен благодаря применению методологии АРИЗ.


Заключение: Будущие Направления для Агентов с Врожденной Изобретательностью


Представленный в данном отчете фреймворк демонстрирует возможность создания нового класса ИИ-агентов, которые выходят за рамки простого выполнения задач и приближаются к способности к творческому, изобретательскому решению проблем. Путем синтеза трех ключевых компонентов — надежной когнитивной архитектуры (модель BDI), структурированного алгоритма для инноваций (АРИЗ) и мощного фреймворка для оркестрации (Semantic Kernel) — становится возможным построить агента, способного не просто следовать плану, но и изобретать новый, когда старый оказывается несостоятельным.
Этот подход открывает значительные перспективы. Агенты, оснащенные таким механизмом, могут применяться в самых разных областях: от автоматизированного проектирования и научных исследований, где они могли бы предлагать нетривиальные гипотезы, до управления сложными системами и устранения неполадок, где стандартные процедуры неэффективны.
Дальнейшие исследования в этом направлении могут развиваться по нескольким ключевым векторам:
                     * Многоагентные Инновационные Команды: Расширение текущей одноагентной модели до многоагентной системы на базе фреймворков, таких как AutoGen. В такой системе разные агенты могут выполнять специализированные роли, определенные в ТРИЗ (например, "Инженер-механик", "Специалист по противоречиям", "Менеджер проекта"), моделируя работу реальной инновационной команды и потенциально достигая еще более синергетического эффекта.36
                     * Формализация Других Методологий: Адаптация и формализация других методологий творческого мышления и инноваций (например, Design Thinking, Lean Innovation) для использования ИИ-агентами. Это позволит создать целый арсенал "мета-эвристик", которые агент сможет выбирать в зависимости от типа проблемы.
                     * Улучшение Механизмов Итерации и Обратной Связи: Текущая модель предполагает линейное выполнение АРИЗ. Будущие версии могут включать циклы обратной связи, позволяющие агенту итеративно уточнять и пересматривать результаты предыдущих шагов АРИЗ, что еще больше приблизит его работу к человеческому творческому процессу.
                     * Глубокая Интеграция с Базами Знаний: Подключение агента к специализированным научным и патентным базам данных для обогащения процесса АРИЗ. Это позволит LLM не только полагаться на свои внутренние знания, но и использовать актуальную внешнюю информацию для генерации более обоснованных и передовых решений.
В конечном счете, создание агентов с врожденной изобретательностью — это шаг к реализации давней мечты об ИИ как о настоящем партнере человека в творчестве и решении самых сложных задач, стоящих перед наукой и технологиями. Предложенный пилот-агент является не конечной точкой, а важной вехой на этом пути.
Источники
                     1. AI Agent Architecture: Breaking Down the Framework of Autonomous Systems - Kanerika, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     2. AI Agent Architecture: Core Principles & Tools in 2025 | Generative AI Collaboration Platform, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     3. What Is Agentic Architecture? | IBM, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     4. Understanding Autonomous Agent Architecture - SmythOS, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     5. Fundamentals of Autonomous AI Agents, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     6. What Are AI Agents? | IBM, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     7. What is AI Agent Planning? | IBM, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     8. Belief–desire–intention software model - Wikipedia, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     9. Understanding BDI Agents in Agent-Oriented Programming - SmythOS, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     10. Leveraging the Beliefs-Desires-Intentions Agent Architecture | Microsoft Learn, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     11. Understanding AI agent types: A guide to categorizing complexity, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     12. What Are AI Agent Protocols? | IBM, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     13. What are Dynamic Agents? | PromptLayer, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     14. AI Agent Architecture Pattern, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     15. How to Build AI Agents with Dynamic Tool Routing - Open ..., дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     16. Diagnosing and Measuring AI Agent Failures: A Complete Guide - Maxim AI, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     17. Prioritizing Real-Time Failure Detection in AI Agents - Partnership ..., дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     18. Prioritizing Real-Time Failure Detection in AI Agents - Partnership on AI, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     19. Contingency Planning For AI Projects - Meegle, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     20. Deploying agentic AI with safety and security: A playbook for technology leaders - McKinsey, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     21. Evaluating AI Agent Performance with Dynamic Metrics - Maxim AI, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     22. What is TRIZ?, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     23. TRIZ Methodology in Engineering and Product Design - Patsnap Eureka, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     24. TRIZ - Theory of Inventive Problem Solving - IAPM, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     25. Introduction to TRIZ – Innovative Problem Solving - EE IIT Bombay, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     26. Master Problem Solving TRIZ Methodologies with AI - Jeda.ai, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     27. (PDF) An Introduction to ARIZ -The Algorithm of Inventive Problem ..., дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     28. ARIZ : The Algorithm for Inventive Problem Solving, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     29. Algorithm of Inventive Problem Solving - Mycoted, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     30. 14. The Algorithm for Inventive Problem Solving (ARIZ-85C) - Springer Professional, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     31. Application of Algorithm for Inventive Problem Solving (ARIZ) for the Heat Dissipation of Energy Storage Supply System for High-Power Locomotive - MDPI, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     32. TRIZ-GPT: An LLM-augmented method for problem-solving - arXiv, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     33. A Multi-Agent LLM Approach for TRIZ-Based Innovation - SciTePress, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     34. [2403.13002] AutoTRIZ: Automating Engineering Innovation with TRIZ and Large Language Models - arXiv, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     35. Case study: is there a space for TRIZ in the era of ChatGPT? | Proceedings of the Design Society, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     36. Innovation, Agentified: How TRIZ Got Its AI Makeover | Cognaptus, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     37. [2506.18783] TRIZ Agents: A Multi-Agent LLM Approach for TRIZ-Based Innovation - arXiv, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     38. A Multi-Agent LLM Approach for TRIZ-Based Innovation - arXiv, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     39. 40 TRIZ Principles, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     40. Semantic Kernel Agent Framework | Microsoft Learn, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     41. Semantic Kernel overview for .NET - Microsoft Learn, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     42. Building Production-Ready AI Agents with Semantic Kernel - DEV Community, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     43. What are Planners in Semantic Kernel | Microsoft Learn, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     44. AI Agent Frameworks: Choosing the Right Foundation for Your Business | IBM, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     45. AutoGen - Microsoft Research, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     46. Built my first AI agent with Microsoft Agent Framework in Python and .NET, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     47. Introduction to Microsoft Agent Framework, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     48. Build Your First AI Agent with Semantic Kernel (Python & C#): Email Summarizer + Daily Planner, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     49. How to quickly start with Semantic Kernel | Microsoft Learn, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     50. Using Semantic Kernel in C# and .NET | by Michael Gold | Medium, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     51. Building AI-Powered .NET Applications with Semantic Kernel | by Andreas Schultz | Medium, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     52. C# - Semantic Kernel - Using Planners correctly - Stack Overflow, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     53. Semantic Kernel: Function Calling and Planners - Jamie Maguire, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     54. [Bug]: When using .NET version of Autogen, if an agent makes parallels function calls using OpenAI, the next response throws an exception about invalid message ordering with tools calls · Issue #2722 - GitHub, дата последнего обращения: ноября 1, 2025, [URL_REMOVED]
                     55. AutoGen Agentic Framework Data truncation error encountered during data processing., дата последнего обращения: ноября 1, 2025, [URL_REMOVED]