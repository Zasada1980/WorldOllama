Комплексный анализ: Генерация, Гибридность и Архитектура Пользовательских Инструкций GitHub Copilot




I. Систематический Анализ Пользовательских Инструкций (Custom Instructions)




A. Определение и Фундаментальная Роль


Пользовательские инструкции (ПИ) представляют собой набор руководящих принципов и правил, определенных пользователем, которые автоматически влияют на то, как GitHub Copilot генерирует код и обрабатывает задачи разработки.1 Основная цель этой функциональности — обеспечить согласованные и предсказуемые ответы ИИ, соответствующие уникальным практикам кодирования, стандартам и требованиям конкретного проекта.1
На практике ПИ устраняют необходимость вручную включать один и тот же контекст (например, «используй этот фреймворк», «следуй этому стилю именования», «избегай этой устаревшей библиотеки») в каждый отдельный запрос к чату.1 Это эффективно применяет принцип DRY (Don't Repeat Yourself) к взаимодействиям с ИИ, позволяя разработчикам и командам один раз кодифицировать свои "институциональные знания".4


B. Критическое Ограничение: Разделение Чата и Автодополнения


Ключевым и часто упускаемым аспектом ПИ является их область применения. Анализ документации однозначно показывает, что пользовательские инструкции не учитываются и не влияют на автодополнения кода (inline code completions), которые появляются в редакторе по мере ввода текста.1
ПИ применяются исключительно к операциям, инициируемым через представление чата (Chat view) или при выполнении агентных задач.4 Это различие подразумевает фундаментальный архитектурный раскол в работе Copilot.
1. Inline-автодополнение: Оптимизировано для сверхнизкой задержки и использует локальный контекст (окружающий код в открытом файле).
2. Чат/Агентные операции: Являются операциями с более высокой задержкой, но способными обрабатывать значительно больший и более сложный контекст (весь проект, несколько файлов, внешние правила).
Следовательно, ПИ не являются инструментом для исправления стиля генерации кода "на лету" во время набора. Для этой цели по-прежнему необходимо использовать традиционные инструменты, такие как линтеры и конфигурации редактора. Вместо этого ПИ позиционируются как мощный инструмент для стандартизации инженерных процессов, таких как проведение ревью кода, выполнение рефакторинга, генерация тестов и управление сложными, многоэтапными агентными задачами.


C. Модели Хранения и Иерархия Области Видимости


Пользовательские инструкции существуют на трех различных уровнях, образуя каскадную систему применения контекста.5
1. Персональные (Personal): Эти инструкции применяются ко всем взаимодействиям пользователя с Copilot Chat на платформе GitHub.com.5 Они хранятся в настройках профиля пользователя 6 и предназначены для личных предпочтений. Примеры включают: "Всегда отвечай на испанском" или "Всегда приводи примеры кода на TypeScript".6
2. Репозитория (Repository): Инструкции применяются в контексте конкретного репозитория.5 Это основной механизм для обмена знаниями о проекте внутри команды 4, например, определение используемого технологического стека.4
3. Организации (Organization): (В настоящее время в public preview) ПИ применяются ко всем репозиториям и беседам в рамках организации.5
Критически важным аспектом этой "гибридной" модели является механизм разрешения приоритетов. Установлена четкая иерархия: Персональные инструкции имеют наивысший приоритет, за ними следуют инструкции Репозитория, и, наконец, Организации.5
Однако это не простая система переопределения (override). Документация уточняет, что GitHub "объединяет все наборы релевантных инструкций и предоставляет их Copilot".5 Это означает, что LLM получает конкатенацию всех применимых инструкций, а иерархия приоритетов, по-видимому, служит мета-инструкцией для самой модели о том, как разрешать конфликты.
Эта система является вероятностной 4, а не строго детерминированной. Именно поэтому документация настоятельно рекомендует "по возможности избегать предоставления противоречивых наборов инструкций".6 В случае, если "качество ответа" страдает из-за конфликтов, пользователям даже предлагается временно отключать инструкции репозитория.6


II. Таксономия и Синтаксис Генерации Инструкций


Система предоставляет несколько методов определения ПИ, от глобальных файлов до гранулярных, целевых правил.


A. Метод 1: Глобальные Инструкции Репозитория (.github/copilot-instructions.md)


Это основной и наиболее распространенный метод.4 Он заключается в создании единого файла Markdown с именем copilot-instructions.md в каталоге .github/ в корне репозитория.1
Этот файл служит "центральным элементом" 4 и автоматически применяется ко всем запросам чата в данном рабочем пространстве (workspace).1 Он также поддерживается в Visual Studio (помимо VS Code) и на GitHub.com.1 Для его активации может потребоваться включение настройки github.copilot.chat.codeGeneration.useInstructionFiles в VS Code.1


B. Метод 2: Гранулярные, Целевые Инструкции (*.instructions.md)


Для более сложных проектов этот метод позволяет создавать несколько файлов инструкций, каждый из которых нацелен на определенные типы файлов, языки или задачи.1
Хранение:
1. Рабочая область: Файлы хранятся в каталоге .github/instructions/.1 Они специфичны для данного проекта и версионируются вместе с ним.
2. Профиль пользователя: Файлы хранятся в профиле VS Code пользователя. Они доступны во всех рабочих пространствах и могут синхронизироваться между устройствами.1
Активация: Ключевым механизмом активации для этих файлов является блок YAML frontmatter в начале файла, который должен содержать ключ applyTo.1 Этот ключ использует синтаксис glob-паттернов для точного указания, к каким файлам применяются данные инструкции.
* Пример (Python): applyTo: "**/*.py" 1
* Пример (TypeScript/React): applyTo: "**/*.ts,**/*.tsx" 7
* Пример (Ruby Models): applyTo: "app/models/**/*.rb" 7


C. Метод 3: Специализированные Инструкции (settings.json)


Для конкретных, встроенных в IDE задач, ПИ можно определить непосредственно в файле settings.json VS Code (на уровне пользователя или рабочей области).1 Это позволяет точно настраивать поведение Copilot для стандартных действий.
* Генерация описания Pull Request: github.copilot.chat.pullRequestDescriptionGeneration.instructions 1
* Ревью выделенного кода: github.copilot.chat.reviewSelection.instructions 1
* Генерация сообщения коммита: github.copilot.chat.commitMessageGeneration.instructions.1
Инструкции в settings.json могут быть либо встроены как текст (свойство "text": "..."), либо ссылаться на внешний файл Markdown (свойство "file": "guidance/review-rules.md").1


D. Метод 4: Автоматическая Генерация Инструкций


VS Code предоставляет функцию для анализа текущего рабочего пространства и автоматической генерации файла .github/copilot-instructions.md.1 Эта функция ("Generate Instructions" в меню чата) служит отличной отправной точкой, создавая основу ПИ на базе обнаруженных технологий и структуры проекта, которую затем можно доработать вручную.4


E. Метод 5: AGENTS.md (Экспериментальный)


Документация также упоминает поддержку файлов AGENTS.md.1 Этот файл, хранящийся в корне, также автоматически применяется к запросам чата 1 и, по-видимому, является частью развивающейся экосистемы Copilot Agents.9


F. Включение Контекста: Разрешение Противоречия о Ссылках на Файлы


В материалах сообщества наблюдается явное противоречие относительно того, можно ли ссылаться на другие файлы из файла инструкций.
* Противоречие: Некоторые источники категорически заявляют: "Не ссылайтесь на другие файлы... храните всю необходимую информацию в самом файле инструкций".11 Другие предполагают специальный синтаксис, такой как #file:../path 11, или упоминают "обычные markdown-ссылки".12
* Разрешение: Официальная документация VS Code 1 окончательно разрешает этот вопрос. Корректным синтаксисом для ссылки на другие файлы (для включения их содержимого в контекст) являются стандартные Markdown-ссылки.
Документация 1 приводит явные примеры:
1. Инструкция -> Инструкция: Файл typescript.instructions.md может ссылаться на общие правила: [general coding guidelines](./general-coding.instructions.md).
2. Инструкция -> Файл Кода: Файл ПИ может ссылаться на конкретный файл проекта: [index](../index.ts).
Это не просто гиперссылка; это механизм включения контекста. При обработке ПИ, Copilot "разворачивает" эти Markdown-ссылки и включает содержимое связанных файлов в общий контекст, отправляемый LLM.
Это открытие критически важно: оно означает, что ПИ являются не монолитными, а компонуемой (composable) системой. Вместо дублирования правил 11, разработчики могут создавать модульные, многократно используемые блоки инструкций. Это также является прямым решением проблемы "перегрузки контекста" 12, позволяя создавать компактные, целевые ПИ, которые импортируют только необходимые зависимости.


III. "Гибридность": Деконструкция Продвинутой Модели Взаимодействия


Запрос пользователя о "гибридности" затрагивает сложную экосистему кастомизации Copilot, где пересекаются несколько концепций.2 Для прояснения этой модели взаимодействия необходимо сначала разделить компоненты.


A. Матрица Компонентов Кастомизации Copilot


Следующая таблица систематизирует различные, часто путаемые, компоненты кастомизации:


Компонент (Файл)
	Основное Назначение (Что это?)
	Область Видимости
	Механизм Активации
	Пример Использования
	Источники
	Custom Instructions (.instructions.md)
	Статические Правила. "Физика" проекта.
	Пользователь, Репозиторий (Глобальный/Гранулярный), Организация
	Автоматически (на основе applyTo или глобально)
	"Всегда используй PEP 8."
	1
	Prompt Files (.prompt.md)
	Многоразовая Задача. Шаблон для конкретного действия.
	Рабочая область
	Вручную (через / команду или UI)
	/create-readme
	5
	Custom Chat Modes (.chatmode.md)
	Специализированная "Персона". Эксперт по определенной роли.
	Пользователь, Рабочая область
	Вручную (переключение режима в чате)
	Режим "Рецензент Кода" или "Планировщик"
	16
	Custom Agents (Профили .md)
	Автономный Исполнитель. Выполняет многошаговые задачи.
	Пользователь, Репозиторий, Организация
	Вручную (через @ или назначение задачи)
	"Агент-Тестировщик" или "Мигратор Фреймворка"
	9
	Dynamic Context (@workspace, #file:)
	Контекст "В Моменте". Файлы/символы для текущего запроса.
	Текущий Промпт
	Вручную (ввод @ или # в чате)
	"@workspace объясни поток аутентификации."
	1
	

B. Статический vs. Динамический Контекст (Гибридный Промпт)


Гибридность заключается в том, как статический контекст (из ПИ) объединяется с динамическим контекстом (из @workspace, @selection, #file:) и запросом пользователя.1 Когда пользователь отправляет запрос, например, @workspace рефактори этот компонент, происходит конкатенация контекста.21
Финальный промпт, отправляемый LLM, имеет следующую концептуальную структуру:
1. [СИСТЕМНЫЙ ПРОМПТ] (Содержит все статические ПИ из .instructions.md, .chatmode.md, AGENTS.md, отфильтрованные по applyTo и правилам приоритета).
2. [ДИНАМИЧЕСКИЙ КОНТЕКСТ] (Содержит содержимое файлов, на которые ссылаются @workspace, @selection, #file: и т.д.).
3. [ЗАПРОС ПОЛЬЗОВАТЕЛЯ] (e.g., "рефактори этот компонент").
Эта архитектура показывает, что ПИ действуют как "пре-промпт" 11 или системный промпт, который направляет (grounds) ИИ. ПИ устанавливают правила игры (например, "используй React Hooks").4 Динамический контекст (@workspace) предоставляет предметную область (файлы для работы). Запрос пользователя определяет задачу (рефакторинг). Эта модель позволяет "институциональным знаниям" из ПИ 4 управлять работой агента 18 над конкретными файлами, предоставленными через @workspace.


C. Инструкции как "ДНК" для Персон и Агентов


Анализ показывает, что ПИ (.instructions.md) являются фундаментальными, многоразовыми "строительными блоками" для всей экосистемы кастомизации.
Пользовательские Режимы Чата (.chatmode.md) — это не просто инструкции; это оболочки, которые определяются как "набор инструкций и инструментов".16 Ключевой аспект заключается в том, что они могут (и должны) ссылаться на существующие файлы инструкций.16 Аналогично, ПИ используются для управления поведением автономных агентов.7
Это означает, что ПИ функционируют как компонуемая "ДНК". Команде не нужно переписывать "Правила PEP 8 для Python" для своего "Агента Рефакторинга Python" и своего "Режима Ревью Безопасности Python". Вместо этого:
1. Они создают один файл python.instructions.md, содержащий правила PEP 8.
2. Их файл python-refactor.chatmode.md ссылается на этот файл (используя синтаксис (./instructions/python.instructions.md) 1) и добавляет свои специфичные инструкции (например, "Сосредоточься на читаемости, удалении избыточного кода и принципах SOLID").
Это мощная, иерархическая и компонуемая модель "Instruction-as-Code", которая обеспечивает максимальную многократную используемость и минимальное дублирование.


IV. Практическая Реализация: От Принципов к Производству




A. Лучшие Практики Написания Эффективных Инструкций


Эффективность ПИ зависит от качества их написания. Основная философия заключается в том, чтобы относиться к Copilot как к новому члену команды, которому необходимо предоставить "институциональные знания".4 Не следует быть "пассивно-агрессивным" 4; инструкции должны быть явными.
Синтез лучших практик 4 включает пять ключевых разделов для файла .github/copilot-instructions.md:
1. Обзор Проекта: Высокоуровневое описание того, что создает проект.
2. Технологический Стек: Явное перечисление всех языков, фреймворков, баз данных, ORM и библиотек.
3. Руководства по Кодированию: Правила стиля (табуляция vs. пробелы, точки с запятой), соглашения об именовании, использование type hints.
4. Структура Проекта: Объяснение ключевых каталогов и "почему" они так организованы.
5. Ресурсы: Указатели на важные файлы: скрипты сборки/тестирования (например, start-app.sh, test-project.sh), файлы конфигурации, документация API.
Дополнительные рекомендации включают:
* Использовать ясный, действенный язык ("всегда запускай npm install перед сборкой").22
* Сосредоточиться на том, что делать, а не на том, чего избегать.23
* Предоставлять конкретные примеры.23
* Итерировать и улучшать. "Несовершенный" файл инструкций принесет гораздо больше пользы, чем его полное отсутствие.4


B. Архитектурные Паттерны: Примеры для Конкретных Стеков


Ниже приведены конкретные примеры ПИ, адаптированные из документации и руководств:


Python (Общие стандарты)
1




applyTo: "**/*.py"




Стандарты кодирования Python


* Следуйте руководству по стилю PEP 8.
* Всегда используйте 4 пробела для каждого уровня отступа.
* Функции должны иметь описательные имена и включать type hints.
* Пишите четкие и краткие комментарии для каждой функции.
* Используйте f-strings для форматирования строк.
Стек Проекта (Backend: Flask, Frontend: Astro/Svelte) 4:


Tech stack in use




Backend


* Flask используется для API.
* Данные хранятся в Postgres, с SQLAlchemy в качестве ORM.
* Существуют отдельные базы данных для dev, staging и prod.


Frontend


* Astro управляет основным сайтом и роутингом.
* Svelte используется для интерактивности.
* TypeScript используется для всего front-end кода.


Project and code guidelines


* JavaScript/TypeScript должны использовать точки с запятой.
* Всегда использовать type hints в любом языке, который их поддерживает.
* Требуются Unit-тесты, и они должны проходить перед PR.
Next.js + Tailwind CSS 18:


Next.js + Tailwind Development Instructions


Инструкции для высококачественных приложений Next.js со стилизацией Tailwind CSS и TypeScript.


Project Context


* Последняя версия Next.js (App Router)
* TypeScript для безопасности типов
* Tailwind CSS для стилизации


Development Standards




Architecture


* App Router с серверными и клиентскими компонентами
* Группируйте маршруты по функциональности/домену
CSS / Стилизация 11:


CSS Guidelines


* Следуйте методологии BEM для именования классов.
* Используйте вложенность CSS (CSS nesting), где это уместно.
* Включите поддержку темного режима с помощью prefers-color-scheme.
* Отдавайте предпочтение современным единицам измерения (rem, vh, vw).
* Используйте логические свойства (например, margin-inline).


C. Продвинутые Сценарии (Ревью Безопасности, Рефакторинг)


Хотя полные, готовые к использованию файлы для сложных "персон", таких как "Рецензент Безопасности" или "Ведущий по Рефакторингу", не были обнаружены в проанализированных материалах 14, принципы их создания ясны из других фрагментов.
* Для Ревью Безопасности:
   * Можно создать Режим Чата (Chat Mode) с именем "Security Scout".26
   * ПИ для этого режима должны ссылаться на внешние чек-листы безопасности, используя синтаксис Markdown-ссылок (например, Применяй проверки из файла [/security/security-checklist.md]).27
   * Инструкции должны направлять ИИ на поиск конкретных анти-паттернов 28 или следовать руководствам, определенным в файлах промптов, таких как API security review.prompt.md.5
* Для Рефакторинга:
   * Можно создать Режим Чата "Clean Code" 26 или "Агента Рефакторинга".18
   * Эти "персоны" могут выполнять крупномасштабные задачи, такие как "Мигрировать это приложение с React на Vue" 26 или "выполнить рефакторинг в нескольких файлах".18
   * Пользовательские инструкции (.instructions.md) в этом сценарии предоставляют стандарты (целевое состояние), по которым этот рефакторинг должен выполняться (например, "использовать функциональные компоненты", "следовать принципам SOLID").
ПИ должны рассматриваться как "живой документ". Наиболее продвинутое использование — это рассматривать их как CONTRIBUTING.md для ИИ 29, который версионируется и обновляется вместе с кодовой базой, отражая ее текущие стандарты и операционные скрипты.4


V. Ограничения, Производительность и Анти-Паттерны




A. Ключевые Функциональные Ограничения


Несмотря на свою мощность, система ПИ имеет четкие ограничения:
1. Главное Ограничение: Как указано в разделе I-B, ПИ не имеют никакого влияния на inline-автодополнение кода в редакторе.1
2. Ограничения Области Видимости (Экосистема):
   * Персональные ПИ в настоящее время поддерживаются только для Copilot Chat на веб-сайте GitHub.com, а не в IDE.5
   * Целевые ПИ (специфичные для пути, applyTo) на GitHub.com поддерживаются только для Агента Кодирования (Coding Agent) и Ревью Кода (Code Review).7
   * Функция ревью кода в VS Code в настоящее время поддерживает только ПИ уровня репозитория (глобальные), и только при ревью выделенного фрагмента кода, а не всех изменений в файле.7


B. Проблемы Производительности: Перегрузка Контекста и Лимиты Токенов


Это критическое ограничение, выявленное сообществом разработчиков.12
* Проблема: Пользователи сообщают, что по мере роста файла copilot-instructions.md (в одном случае приближаясь к 9 000 токенов) возникают серьезные проблемы с производительностью.12
* Симптомы: 1. Заметное замедление ответов Copilot. 2. ИИ начинает "зацикливаться или повторять задачи без необходимости", что, по-видимому, вызвано "контекстной перегрузкой" (context overload).12
* Анализ Причины: "Общий Контекст" (Total Context), обсуждавшийся в Разделе III-B, имеет конечный размер (контекстное окно LLM). Чрезмерно большой, монолитный файл ПИ (например, на 9 000 токенов) "съедает" большую часть этого бюджета. В результате остается мало места для фактического динамического контекста (содержимого файлов из @workspace) или самого запроса пользователя. LLM буквально "забывает" либо свои инструкции, либо поставленную задачу, либо контекст кода, что и приводит к зацикливанию и сбоям.
* Решение: Решение этой проблемы было представлено в Разделе II-F — модульность. Вместо одного гигантского монолитного файла (анти-паттерн), следует использовать гранулярные файлы (.instructions.md) в папке .github/instructions/ с applyTo 1 и Markdown-ссылками.1 Эта архитектура позволяет системе динамически загружать в контекст только те ПИ, которые релевантны текущей задаче (например, только 2 000 токенов из python.instructions.md при редактировании .py файла), сохраняя тем самым драгоценный "бюджет токенов".


C. Распространенные Анти-Паттерны


1. Противоречивые Инструкции: Предоставление конфликтующих правил на разных уровнях (например, Персональные vs. Репозиторий).6 Это приводит к "непредсказуемым результатам" 11, поскольку LLM получает смешанные сигналы.
2. Двусмысленность / Расплывчатость: Нечеткие или расплывчатые инструкции.11 "Оставление решений на усмотрение ИИ" 11 приводит к вероятностным, а не детерминированным результатам.
3. Избыточность / Дублирование: Повторение одних и тех же правил в нескольких файлах.11 Это следует решать с помощью модульности и Markdown-ссылок.1
4. Чрезмерный Инжиниринг: Попытки создать "идеальный" файл с первой попытки. Итеративный подход, начинающийся с "несовершенного" файла, гораздо эффективнее.4


VI. Итоговый Анализ и Стратегические Рекомендации




A. Синтез: От Индивидуальной Помощи к Организационной Стандартизации


Анализ показывает, что зрелая стратегия внедрения Copilot в организации представляет собой переход от повышения индивидуальной продуктивности (через inline-автодополнение) к достижению организационной согласованности (через чат, агентов и ревью кода).3
Пользовательские инструкции и связанная с ними гибридная экосистема (Режимы Чата, Агенты, Файлы Промптов) являются главным механизмом для достижения этой согласованности. По сути, это система "Policy-as-Code" ("Политика-как-Код"), предназначенная для управления и стандартизации взаимодействий с ИИ в масштабе всей команды или организации.


B. Стратегические Рекомендации для Технических Лидеров


1. Примите Менталитет "Instruction-as-Code" (Инструкция-как-Код). Относитесь ко всем файлам .instructions.md, .chatmode.md и AGENTS.md как к критически важным артефактам проекта. Они должны проходить ревью кода, версионироваться в Git и поддерживаться в актуальном состоянии наравне с основной кодовой базой.
2. Внедрите 3-Уровневую Иерархию Контекста.5
   * Уровень Организации: Используйте для минимальных, универсальных правил (например, "Стандарты безопасности", "Запрет на использование нелицензированных зависимостей").
   * Уровень Репозитория: Основной контекст проекта. Используйте .github/copilot-instructions.md для "5 Советов" (обзор, стек, ресурсы).4
   * Уровень Персональный: Строго зарезервирован для личных предпочтений (язык ответа, стиль) 6, чтобы избежать конфликтов.6
3. Применяйте Модульность; Избегайте Монолитов.
   * Агрессивно избегайте создания одного гигантского copilot-instructions.md, который приведет к перегрузке контекста.12
   * Немедленно рефакторите все правила, специфичные для языков или фреймворков, в отдельные файлы в .github/instructions/ (например, python.instructions.md, react.instructions.md).
   * Используйте applyTo 1 для их автоматической и эффективной (с точки зрения токенов) загрузки.
   * Используйте Markdown-ссылки 1 для импорта общих правил и соблюдения принципа DRY.3
4. Создайте "Библиотеку" Персон и Агентов.
   * Не просто пишите инструкции; создавайте инструменты для команды.
   * Разработайте внутреннюю библиотеку "персон" (файлы .chatmode.md) для общих ролей (например, SecurityReviewer.chatmode.md, RefactorLead.chatmode.md, DocumentationWriter.chatmode.md).16
   * Убедитесь, что эти режимы ссылаются на модульные ПИ ("ДНК") 16, а не дублируют их.
5. Устраните "Пробел" в Автодополнении.
   * Это наиболее важное стратегическое следствие. Признайте, что ПИ не влияют на inline-автодополнение.1
   * Следовательно, команда должна продолжать использовать традиционные инструменты (ESLint, Prettier, EditorConfig, линтеры стилей) для обеспечения стандартов в момент написания кода.
   * Пользовательские инструкции стратегически используются для пост-фактум задач, управляемых чатом: ревью кода, генерация тестов, рефакторинг и объяснение существующего кода. Разделение этих двух областей применения является ключом к успешной интеграции Copilot в рабочий процесс.
Источники
1. Use custom instructions in VS Code, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
2. Customize chat to your workflow - Visual Studio Code, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
3. Master GitHub Copilot Custom Instructions - YouTube, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
4. 5 tips for writing better custom instructions for Copilot - The GitHub ..., дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
5. About customizing GitHub Copilot responses, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
6. Adding personal custom instructions for GitHub Copilot, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
7. Adding repository custom instructions for GitHub Copilot, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
8. How can I properly setup copilot custom instructions advanced use cases coming from cursor rules : r/vscode - Reddit, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
9. Best practices for using GitHub Copilot to work on tasks, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
10. Using GitHub Copilot CLI, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
11. copilot-instructions.md has helped me so much. : r/ChatGPTCoding - Reddit, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
12. Guidance on efficient use of copilot-instructions.md : r/GithubCopilot, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
13. Announcing Awesome Copilot MCP Server - Microsoft for Developers, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
14. github/awesome-copilot: Community-contributed instructions, prompts, and configurations to help you make the most of GitHub Copilot. - GitHub, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
15. Your first custom instructions - GitHub Docs, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
16. Custom chat modes in VS Code, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
17. Get started with GitHub Copilot in VS Code, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
18. Introducing the Awesome GitHub Copilot Customizations repo - Microsoft for Developers, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
19. Best practices for using GitHub Copilot to work on tasks - GitHub Enterprise Cloud Docs, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
20. Manage context for AI - Visual Studio Code, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
21. Announcing a free GitHub Copilot for VS Code, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
22. дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
23. Write effective instructions for declarative agents | Microsoft Learn, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
24. дата последнего обращения: января 1, 1970, [URL_REMOVED]
25. дата последнего обращения: января 1, 1970, [URL_REMOVED]
26. Modes of Chatting with GitHub Copilot - CODE Magazine, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
27. Using GitHub Copilot code review, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
28. Anti-patterns - GitHub Well-Architected, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]
29. Get more out of Copilot Workspace with custom instructions - Willem's Fizzy Logic, дата последнего обращения: ноября 7, 2025, [URL_REMOVED]