Архитектура автоматизированной системы гигиены проекта: Очистка и архивация рабочей области




Введение: Доктрина "чистого рабочего пространства" — основа скорости и стабильности




Стратегическая цена беспорядка


В жизненном цикле любого программного проекта накопление артефактов, временных файлов и устаревших данных является неизбежным процессом. На первый взгляд, эта проблема может показаться незначительным неудобством. Однако на практике замусоренная рабочая область представляет собой значительный технический долг. "Шум" в проекте — это не просто лишние файлы; это скрытый барьер, который замедляет анализ, усложняет отладку, раздувает резервные копии до неприемлемых размеров и, что особенно опасно, увеличивает риск случайного включения временных или конфиденциальных файлов в систему контроля версий.1 Таким образом, задача выходит за рамки простой "уборки". Она трансформируется в стратегическую практику "гигиены проекта", направленную на поддержание здоровья и эффективности среды разработки на всех этапах.


Представление архитектуры "команды агентов"


Для решения этой задачи предлагается модульная, автоматизированная система, построенная по метафоре скоординированной "команды агентов". Каждый агент представляет собой программный компонент, реализованный в виде функции или скрипта, с четко определенной зоной ответственности. Оркестрация этих агентов осуществляется мастер-скриптом.
* Агент Манифеста: Не выполняет активных действий, но является источником истины. Он определяет "золотой образ" проекта — декларативное описание того, какие файлы и директории являются неотъемлемой частью проекта, а какие — утилизируемым мусором.
* Агент Санации: Активно очищает рабочее пространство, руководствуясь правилами, установленными Агентом Манифеста. Его главная задача — хирургически точное удаление всего лишнего без вреда для проекта.
* Агент Архивист: Создает безупречный, сжатый архив чистого состояния проекта. Этот архив идеально подходит для резервного копирования, передачи или долгосрочного хранения.


Единый источник истины как unifying principle


Центральным архитектурным решением этой системы является создание единого, версионируемого файла-манифеста (например, .projectclean). Этот файл служит единственным источником истины, который определяет логику исключений для всех агентов. Такой подход гарантирует консистентность операций, радикально упрощает сопровождение системы и делает процесс очистки полностью прозрачным и аудируемым. Любое изменение в правилах гигиены проекта фиксируется в системе контроля версий, что позволяет отслеживать, кто, когда и почему внес то или иное изменение.


Безопасность через "пробный запуск" (Dry Run): не подлежащий обсуждению мандат


Главное опасение при автоматизации удаления файлов — это риск необратимой потери критически важных данных. Пользователь четко обозначил эту "красную линию". Поэтому наиболее важной функцией предлагаемой системы является режим "пробного запуска" (dry run). Этот режим должен быть не опциональным дополнением, а фундаментальной частью архитектуры. Система спроектирована таким образом, что любое деструктивное действие может быть предварительно симулировано без внесения каких-либо реальных изменений в файловую систему. Этот подход, являющийся лучшей практикой в системном администрировании, позволяет пользователю получить полный и верифицируемый отчет о том, какие файлы будут удалены, прежде чем дать команду на их фактическое удаление.3 Это обеспечивает максимальный контроль и уверенность в безопасности операций.
________________


Раздел 1: Агент Манифеста — Определение "золотого образа" проекта


Этот раздел посвящен наиболее важному подготовительному этапу: созданию исчерпывающего, машиночитаемого плана, который однозначно разделяет сущность проекта и сопутствующий ему "шум". Этот план, или манифест, является фундаментом для всех последующих автоматизированных действий.


1.1. Использование .gitignore как фундаментальной эвристики


Анализ любого проекта на предмет очистки логично начинать с уже существующих артефактов, определяющих его структуру и состав. Файл .gitignore является именно таким артефактом. Это собственная декларация проекта о том, какие файлы и каталоги считаются неважными, специфичными для окружения или генерируемыми в процессе работы.7 Он представляет собой expertly curated список исключений, созданный разработчиками проекта. Более того, существуют общедоступные репозитории, такие как официальный репозиторий GitHub, которые содержат тысячи шаблонов
.gitignore для различных языков, фреймворков и IDE.9 Эти шаблоны являются бесценным ресурсом и отправной точкой для создания нашего манифеста очистки.
В качестве первого шага реализации, содержимое существующего в проекте файла .gitignore следует использовать как основу для нашего главного файла исключений. Этот простой шаг немедленно синхронизирует процесс очистки со стратегией контроля версий, обеспечивая базовый уровень консистентности.


1.2. Анатомия проектного мусора: комплексная таксономия


Для создания надежного манифеста необходимо систематически идентифицировать все потенциальные источники беспорядка. Проектный "шум" можно классифицировать по категориям, что упрощает его идентификацию и описание с помощью шаблонов. Ниже представлен подробный контрольный список шаблонов файлов и каталогов, которые следует рассмотреть для включения в манифест исключений, сгруппированных по категориям:
* Директории с результатами сборки: Каталоги, куда компиляторы и сборщики помещают конечные артефакты.
   * Шаблоны: /uild/, /uilds/, /bin/, /out/, /target/.7
* Промежуточные артефакты компиляции: Временные файлы, создаваемые в процессе сборки.
   * Шаблоны: /[Oo]bj/, *.o, *.pyc, *.class, *.dwo.7
* Кэши зависимостей: Директории, содержащие загруженные библиотеки и пакеты. Часто являются основным источником раздувания размера проекта.
   * Шаблоны: /node_modules/, /packages/, /.terraform/.7
* Файлы журналов и времени выполнения: Логи, файлы блокировок и временные файлы, создаваемые приложением во время работы.
   * Шаблоны: /[Ll]ogs/, *.log, *.lock, *.tmp.7
* Настройки IDE и пользовательские файлы: Конфигурационные файлы, специфичные для среды разработки конкретного пользователя.
   * Шаблоны: /[Uu]serettings/, .idea/, .vscode/ (за исключением файлов, которые могут быть общими, например launch.json), .DS_Store, Thumbs.db.7
* Отчеты о тестировании и покрытии кода: Результаты, генерируемые инструментами тестирования.
   * Шаблоны: /coverage/, junitreports/.
* Локальные архивы и временные резервные копии: Файлы, созданные пользователем для временного хранения. Пользователь явно упомянул Md и zip afqks (интерпретируется как Markdown-файлы и zip-архивы, не являющиеся частью исходного кода).
   * Шаблоны: *.zip, *.tar.gz, *.bak, *.md.


1.3. Создание манифеста .projectclean


Хотя .gitignore является отличной отправной точкой, его предназначение — управление файлами в Git, а не администрирование локальной файловой системы. Например, может быть полезно хранить локально последние файлы журналов для отладки, но при этом никогда не включать их в коммиты. Следовательно, для целей очистки и архивации более эффективным является использование выделенного, специально созданного манифеста.
Предлагается создать в корне проекта файл с именем .projectclean. Для обеспечения единообразия и простоты использования он будет использовать тот же синтаксис глоббинга (wildcard patterns), что и .gitignore.8 Это позволяет использовать такие конструкции, как
logs/ для исключения каталога, *.log для исключения файлов по маске и **/logs для рекурсивного поиска. Ниже приведен пример такого файла с подробными комментариями, который синтезирует шаблоны из представленной выше таксономии.






#.projectclean - Единый источник истины для гигиены проекта

# 1. Кэши зависимостей
# Исключаем директории с пакетами, которые могут быть восстановлены.
/node_modules/
/vendor/
/packages/

# 2. Результаты сборки и компиляции
# Исключаем все, что генерируется процессом сборки.
/uild/
/ist/
/target/
/[Oo]bj/
*.o
*.class
*.pyc

# 3. Логи и временные файлы
# Исключаем файлы, которые генерируются во время выполнения.
/[Ll]ogs/
*.log
*.tmp
*.lock

# 4. Файлы IDE и специфичные для ОС
# Исключаем конфигурации, которые не должны быть общими.
.idea/
.vscode/
.DS_Store
Thumbs.db

# 5. Локальные архивы и бэкапы
# Исключаем временные архивы, созданные пользователем.
*.zip
*.tar
*.gz
*.rar
*.bak

# 6. Отчеты
/coverage/
/reports/



Манифест как декларативная плоскость управления


Создание централизованного манифеста — это не просто удобство, а фундаментальное архитектурное решение. Традиционный подход к написанию скриптов очистки часто включает жестко закодированные пути и команды, разбросанные по всему коду (rm -rf build, find. -name "*.log" -delete). Такой подход хрупок, сложен в поддержке и непрозрачен для команды. Если появляется новый тип артефакта, необходимо изменять сам скрипт, что требует знаний в области скриптовых языков и несет риск внесения ошибок.
Переход к модели с внешним файлом-манифестом, таким как .projectclean, меняет парадигму. Вместо того чтобы иметь отдельную логику исключений для агента очистки и агента архивации, мы создаем единый мастер-манифест. Агент Санации (например, использующий rsync) будет читать этот файл для определения, что не удалять. Агент Архивист (например, tar) будет читать тот же самый файл для определения, что не включать в архив.14
Это превращает простой текстовый файл в декларативную плоскость управления (declarative control plane). Команда проекта может управлять поведением всей системы гигиены, просто редактируя этот файл и фиксируя изменения в системе контроля версий. Не нужно трогать основной скрипт автоматизации. Это полностью соответствует принципам современного DevOps и Infrastructure-as-Code (инфраструктура как код), где конфигурация отделена от логики исполнения. Процесс становится самодокументируемым, аудируемым и доступным для изменения даже тем членам команды, которые не являются экспертами в написании скриптов.
________________


Раздел 2: Агенты Санации — Стратегия безопасной и эффективной очистки


Этот раздел посвящен практической реализации процесса очистки, с абсолютным приоритетом на безопасности и предотвращении случайной потери данных, как того требует "красная линия" пользователя. Система строится на принципах прозрачности, многоуровневости и использования наиболее подходящих инструментов для каждой задачи.


2.1. Иерархия очистки: сначала специализированные инструменты


Удаление файлов по общим шаблонам — мощный, но потенциально грубый метод. Многие современные экосистемы разработки предоставляют собственные, специализированные утилиты для очистки, которые обладают глубоким пониманием структуры проекта и могут выполнять более интеллектуальную работу. Например, команда dotnet clean в.NET не просто удаляет папки bin и obj, но делает это с учетом текущей конфигурации сборки (например, Debug или Release), что предотвращает удаление артефактов, необходимых для другого окружения.16 Аналогично,
mvn clean в мире Java или npm prune для Node.js выполняют очистку, специфичную для их экосистем.
Поэтому предлагается двухэтапный процесс санации:
* Этап 1 (Специализированный): Выполнение команд, специфичных для фреймворка или платформы проекта. Это гарантирует корректную обработку сложных, скомпилированных артефактов и зависимостей. Примеры команд: dotnet clean, mvn clean, gradle clean.
* Этап 2 (Общий): Использование универсального инструмента на основе шаблонов для удаления оставшегося мусора (логов, файлов IDE, временных архивов), который определен в манифесте .projectclean.
Такой иерархический подход обеспечивает максимальную точность и безопасность, делегируя часть работы инструментам, которые лучше всего "знают" проект.


2.2. Основной агент: паттерн инверсии с rsync


Наиболее интуитивный, но и самый опасный способ очистки — это итерация по списку шаблонов и выполнение команды rm -rf для каждого из них. Этот подход не прощает ошибок: опечатка в пути или шаблоне может привести к катастрофическим последствиям.
Гораздо более безопасной и мощной является альтернативная стратегия: определить, что нужно сохранить, и удалить все остальное. Утилита rsync идеально подходит для этой задачи, хотя ее применение здесь может показаться нетрадиционным. Техника, которую можно назвать "инверсией rsync", работает следующим образом:
1. Создается временная, абсолютно пустая директория: mkdir -p /tmp/empty_dir.
2. Запускается rsync для "синхронизации" этой пустой директории с целевой директорией проекта.
3. Используется флаг --exclude-from=.projectclean. Этот флаг инструктирует rsync не трогать в директории проекта никакие файлы или каталоги, соответствующие шаблонам из нашего манифеста.
4. Используется ключевой флаг --delete. Он приказывает rsync удалить в целевой директории (нашем проекте) любой файл, которого нет в исходной директории (пустой) и который не защищен правилом исключения.
5. В результате rsync выполняет хирургически точное удаление всего, что не было явно указано как необходимое в манифесте .projectclean.
Этот подход основан на "белом списке" (whitelist), что по своей природе безопаснее, чем подход на основе "черного списка" (blacklist), который реализуется через rm.


2.3. Сеть безопасности: архитектура глобального режима "пробного запуска"


Исследования единодушны в том, что возможность "пробного запуска" (dry run) является критически важной для любых автоматизированных систем, выполняющих деструктивные операции.3 Эта функция не может быть второстепенной; она должна быть заложена в ядро архитектуры всей системы.
Реализация надежного режима dry run в мастер-скрипте будет выглядеть следующим образом:
* Мастер-скрипт будет принимать флаг командной строки, например --dry-run или -n.
* При наличии этого флага будет установлена глобальная переменная, например, DRY_RUN_FLAG=true.
* Все деструктивные команды будут инкапсулированы в функции-обертки. Например, функция execute_rsync() будет проверять значение DRY_RUN_FLAG. Если флаг установлен, она добавит к команде rsync флаг -n (или --dry-run).3
rsync в этом режиме симулирует весь процесс синхронизации и выводит подробный отчет о том, какие файлы были бы удалены, не прикасаясь к ним.
* Для команд, у которых нет встроенного режима dry run (например, dotnet clean), функция-обертка будет просто выводить в консоль команду, которая была бы выполнена, вместо ее фактического запуска, используя команду echo.17
* Весь вывод в режиме dry run будет четко помечен префиксом ``, предоставляя пользователю полный и понятный отчет о всех планируемых действиях. Это позволяет верифицировать корректность работы логики перед тем, как разрешить реальные изменения.


Паттерн очистки через "инверсию контроля": внутренняя безопасность и сопровождаемость


Выбор между традиционным подходом (rm) и инверсионным (rsync) — это не просто выбор инструмента, это выбор философии безопасности. Основной страх пользователя — случайное удаление важных файлов. Традиционный скрипт, основанный на "черном списке", требует от разработчика идеального знания всех возможных типов "мусора". Если в проекте появляется новый тип артефакта (например, новый каталог логов audit_logs), скрипт не будет знать о нем, и беспорядок продолжит накапливаться. Что еще хуже, опечатка в шаблоне (rm -rf / important/dir вместо ./important/dir) может иметь фатальные последствия.
Паттерн rsync --delete из пустого источника с файлом исключений --exclude-from переворачивает эту логику. Это подход на основе "белого списка": вы определяете, что нужно сохранить. Это смещает бремя ответственности. Вместо того чтобы знать все возможное разнообразие мусора, разработчику достаточно поддерживать актуальный список того, что является сущностью проекта. Все, что не входит в этот список, по определению считается утилизируемым.
Это кардинально повышает безопасность и упрощает сопровождение. Если в проект добавляется новый важный файл (например, new_config.json), процесс очистки автоматически его удалит, если только он не будет явно добавлен в "белый список" .projectclean. Это заставляет разработчиков быть более осознанными в отношении того, что составляет ядро их проекта, делая его структуру более явной и самодокументируемой. Система "безопасно падает" (fails safely) в сторону чистоты, предотвращая накопление мусора, а не реагируя на него постфактум.
________________


Раздел 3: Агент Архивист — Создание безупречных резервных копий с максимальной эффективностью


Этот раздел напрямую решает вторую задачу пользователя: создание чистой, архивированной модели проекта для резервного копирования. Вместо последовательного выполнения двух операций (очистка, затем архивация) предлагается более эффективная, однопроходная методология.


3.1. Принцип эффективности: очистка во время архивации, а не до нее


Запрос пользователя подразумевает двухэтапный процесс: 1) очистить рабочий каталог; 2) заархивировать очищенный каталог. Такой подход включает две отдельные, потенциально медленные операции ввода-вывода на диске. Сначала одна утилита проходит по дереву каталогов для удаления файлов, а затем вторая утилита снова проходит по тому же дереву для их чтения и архивации.
Более эффективный подход заключается в выполнении одной операции, которая читает исходный, замусоренный каталог и напрямую записывает чистый архив. Агент Архивист должен работать с оригинальной директорией проекта и использовать свои встроенные возможности фильтрации для создания безупречного архива за один проход. Это не только экономит время и ресурсы, но и снижает сложность всего процесса.


3.2. Архивист tar: стандарт Unix


Утилита tar является стандартом де-факто для архивации в Unix-подобных системах. Ее ключевой особенностью для нашей задачи является опция --exclude-from=FILE (или ее короткий аналог -X FILE).14 Эта опция позволяет
tar считывать шаблоны исключений непосредственно из нашего центрального манифеста .projectclean. Это обеспечивает идеальную интеграцию и консистентность с Агентом Санации.
Пример команды с подробными комментариями:


Bash




# Создать сжатый tar-архив (archive.tar.gz) из текущей директории (.)
# -c: создать новый архив (create)
# -z: сжать с помощью gzip
# -v: выводить подробную информацию (verbose)
# -f: указать имя файла архива (file)
# --exclude-from: прочитать шаблоны из.projectclean и исключить соответствующие файлы/директории

tar -czvf project-backup-$(date +%Y%m%d).tar.gz --exclude-from=.projectclean.

При использовании tar важно помнить о распространенных ошибках. Например, при прямом использовании опции --exclude (а не --exclude-from) необходимо заключать шаблон в кавычки (--exclude='*.log'), чтобы предотвратить его интерпретацию командной оболочкой.14 Также в некоторых версиях
tar флаги исключения должны быть указаны до исходной директории.21


3.3. Архивист zip: кросс-платформенная совместимость


Формат zip является еще одним популярным выбором, особенно когда требуется совместимость с операционными системами Windows, где он поддерживается нативно. Механизм исключения в zip использует флаг -x.22 В отличие от
tar, стандартная реализация zip не имеет прямой опции для чтения исключений из файла, что требует небольшого скриптового обходного пути для интеграции с нашим манифестом.
Для сохранения принципа "единого источника истины" можно использовать небольшой скрипт, который читает файл .projectclean построчно и динамически формирует команду zip с множеством флагов -x.


Bash




# Инициализировать массив для аргументов исключения
ZIP_EXCLUDE_ARGS=()

# Прочитать.projectclean построчно
while IFS= read -r pattern; do
 # Пропустить пустые строки и комментарии
 [[ -z "$pattern" |

| "$pattern" == \#* ]] && continue
 # Добавить шаблон в массив аргументов с флагом -x
 ZIP_EXCLUDE_ARGS+=(-x "$pattern")
done <.projectclean

# Выполнить команду zip с динамически сформированным списком исключений
zip -r project-backup-$(date +%Y%m%d).zip. "${ZIP_EXCLUDE_ARGS[@]}"

Этот пример демонстрирует, как центральный манифест может быть адаптирован для инструментов, которые не поддерживают его нативно. Это сохраняет гибкость системы и позволяет ей работать с различными инструментами, не нарушая основной архитектурный принцип.


Таблица 1: Сравнение команд агентов-архивистов


Чтобы помочь в выборе наиболее подходящего архивиста для конкретных нужд, ниже приведена сравнительная таблица. Выбор между tar и zip часто зависит от экосистемы проекта и предполагаемых сценариев использования резервной копии.
Характеристика
	tar (с gzip)
	zip
	Анализ и рекомендации
	Исключение из файла
	Нативная поддержка через --exclude-from=.projectclean. Просто и эффективно.
	Отсутствие нативной поддержки. Требуется скрипт-обертка для формирования аргументов.
	tar предпочтительнее для простоты. Прямая интеграция с файлом манифеста чище и менее подвержена ошибкам.
	Сжатие
	Обычно более высокая степень сжатия с gzip (.tar.gz) или bzip2.
	Хорошее сжатие, но часто немного менее эффективное, чем gzip.
	Для минимизации размера резервной копии tar часто является лучшим выбором.
	Портативность
	Универсален на Linux/macOS. Требует дополнительных инструментов (например, 7-Zip или WSL) на Windows.
	Нативная поддержка практически во всех современных ОС, включая Windows.
	Для архивов, которые должны легко открываться на Windows без дополнительного ПО, zip является победителем.
	Права доступа
	Точно сохраняет права доступа и владения файлами в стиле Unix.
	Может быть менее надежным при работе со сложными правами доступа Unix.
	Для резервного копирования серверных сред, где права доступа критически важны, tar более надежен.
	Итог
	Идеален для разработки в среде Linux/macOS и для резервного копирования серверов.
	Идеален для кросс-платформенного распространения и проектов с участием пользователей Windows.
	Выбор зависит от экосистемы проекта. Мастер-скрипт в идеале должен поддерживать оба варианта.
	________________


Раздел 4: Оркестрация и автоматизация — Завершенный скрипт рабочего процесса


Этот заключительный раздел объединяет все предыдущие концепции в единый, готовый к использованию и хорошо документированный мастер-скрипт. Этот скрипт является практическим воплощением "команды агентов" и представляет собой гибкий, удобный и безопасный инструмент.


4.1. Мастер-скрипт: project-hygiene.sh


Конечным продуктом является единый, надежный скрипт, который инкапсулирует всю логику. Ниже представлен полный скрипт на Bash с подробными комментариями, объясняющими его ключевые особенности:
   * Шебанг и обработка ошибок: Использование #!/bin/bash и set -euo pipefail гарантирует, что скрипт будет выполняться с помощью Bash и немедленно завершится при возникновении любой ошибки, предотвращая непредсказуемое поведение.
   * Разбор аргументов: Профессиональный цикл getopts используется для обработки флагов командной строки, таких как --dry-run, --source-dir, --backup-dest, --archive-type=[tar|zip] и --help. Это делает скрипт гибким и самодокументируемым.18
   * Функциональная модульность: Логика разделена на четкие функции: run_specialist_cleaners(), run_sanitization_agent(), run_archivist_agent(), что улучшает читаемость и упрощает сопровождение.
   * Загрузка конфигурации: Скрипт автоматически ищет и использует манифест .projectclean в исходной директории проекта.
   * Логирование и подробный вывод: Четкие сообщения echo информируют пользователя о каждом шаге. Вывод в режиме `` визуально выделяется для предотвращения путаницы.


Bash




#!/bin/bash

# project-hygiene.sh: Скрипт для очистки и архивации рабочей области проекта.
# Устанавливаем строгий режим для безопасности.
# -e: немедленно выйти, если команда завершается с ненулевым статусом.
# -u: считать использование неустановленной переменной ошибкой.
# -o pipefail: возвращать статус последней команды в конвейере, которая завершилась с ошибкой.
set -euo pipefail

# --- Переменные по умолчанию ---
SOURCE_DIR="."
BACKUP_DEST="."
ARCHIVE_TYPE="tar"
DRY_RUN=false
MANIFEST_FILE=".projectclean"

# --- Функции ---

# Функция для вывода справки
usage() {
   echo "Usage: $0 [-n][-t tar|zip]"
   echo "  -n, --dry-run      Симулировать выполнение без внесения изменений."
   echo "  -s, --source       Директория проекта для очистки (по умолчанию:.)."
   echo "  -d, --dest         Директория для сохранения архива (по умолчанию:.)."
   echo "  -t, --type         Тип архива: 'tar' или 'zip' (по умолчанию: tar)."
   echo "  -h, --help         Показать эту справку."
   exit 1
}

# Функция для логирования с учетом режима dry-run
log() {
   if; then
       echo " $1"
   else
       echo "$1"
   fi
}

# Функция для выполнения команд с учетом режима dry-run
execute() {
   if; then
       log "Команда для выполнения: $@"
   else
       log "Выполнение: $@"
       eval "$@"
   fi
}

# Агент Санации
run_sanitization_agent() {
   log "--- Запуск Агента Санации ---"
   
   local manifest_path="${SOURCE_DIR}/${MANIFEST_FILE}"
   if [! -f "$manifest_path" ]; then
       echo "Ошибка: Файл манифеста '${manifest_path}' не найден."
       exit 1
   fi

   # Этап 1: Специализированные очистители (пример для.NET)
   if; then
       execute "dotnet clean \"${SOURCE_DIR}\""
   fi
   # Здесь можно добавить другие специализированные команды (mvn clean, etc.)

   # Этап 2: Общая очистка с помощью rsync
   log "Очистка на основе '${MANIFEST_FILE}' с использованием rsync..."
   local empty_dir
   empty_dir=$(mktemp -d)
   
   local rsync_opts="-a --delete --exclude-from=\"${manifest_path}\""
   if; then
       rsync_opts+=" -n"
   fi

   execute "rsync ${rsync_opts} \"${empty_dir}/\" \"${SOURCE_DIR}/\""
   rm -rf "$empty_dir"
   log "Санация завершена."
}

# Агент Архивист
run_archivist_agent() {
   log "--- Запуск Агента Архивиста ---"
   
   local manifest_path="${SOURCE_DIR}/${MANIFEST_FILE}"
   if [! -f "$manifest_path" ]; then
       echo "Ошибка: Файл манифеста '${manifest_path}' не найден."
       exit 1
   fi

   local timestamp
   timestamp=$(date +%Y%m%d-%H%M%S)
   local archive_name="project-backup-${timestamp}.${ARCHIVE_TYPE}"
   if; then
       archive_name+=".zip"
       archive_name="${archive_name/.zip.zip/.zip}" # Fix extension
   else
       archive_name+=".tar.gz"
       archive_name="${archive_name/.tar.tar.gz/.tar.gz}" # Fix extension
   fi
   
   local archive_path="${BACKUP_DEST}/${archive_name}"

   log "Создание архива '${archive_path}'..."

   if; then
       # Используем tar с --exclude-from
       execute "tar -czvf \"${archive_path}\" --exclude-from=\"${manifest_path}\" -C \"${SOURCE_DIR}\"."
   elif; then
       # Формируем аргументы для zip
       local zip_exclude_args=()
       while IFS= read -r pattern; do
           [[ -z "$pattern" |

| "$pattern" == \#* ]] && continue
           zip_exclude_args+=(-x "$pattern")
       done < "$manifest_path"
       
       # Переходим в директорию, чтобы избежать включения полного пути в архив
       (cd "$SOURCE_DIR" && execute "zip -r \"${archive_path}\". \"\${zip_exclude_args[@]}\"")
   else
       echo "Ошибка: Неизвестный тип архива '${ARCHIVE_TYPE}'."
       exit 1
   fi
   log "Архивация завершена."
}


# --- Основная логика ---

# Разбор аргументов командной строки
while [[ $# -gt 0 ]]; do
   key="$1"
   case $key in
       -n|--dry-run)
       DRY_RUN=true
       shift
       ;;
       -s|--source)
       SOURCE_DIR="$2"
       shift; shift
       ;;
       -d|--dest)
       BACKUP_DEST="$2"
       shift; shift
       ;;
       -t|--type)
       ARCHIVE_TYPE="$2"
       shift; shift
       ;;
       -h|--help)
       usage
       ;;
       *)
       echo "Неизвестный параметр: $1"
       usage
       ;;
   esac
done

# Вызов агентов
run_sanitization_agent
run_archivist_agent

echo "--- Все операции успешно завершены ---"



4.2. Интеграция в жизненный цикл разработки


Автоматизированный скрипт приносит максимальную пользу, когда он органично встроен в рабочие процессы. Пользователь упомянул необходимость запуска после каждой "фазы", что подразумевает интеграцию в CI/CD.
   * Ручной запуск: Разработчики могут использовать скрипт локально для очистки своей рабочей области перед началом работы над новой веткой или перед выполнением ресурсоемких операций.
   * Git Hooks: Скрипт можно интегрировать как pre-commit хук для предотвращения случайных коммитов "мусора" (хотя это может замедлить процесс коммита) или как post-merge хук для автоматической очистки после слияния веток.
   * CI/CD Pipeline: Это наиболее мощный сценарий применения. Скрипт может быть запущен как отдельный этап в конвейере непрерывной интеграции. Ниже приведены примеры фрагментов конфигурации для GitLab CI и GitHub Actions, демонстрирующие, как запустить скрипт после успешного завершения этапов сборки и тестирования.
Пример для GitHub Actions (.github/workflows/main.yml):


YAML




jobs:
 build_and_test:
   #... этапы сборки и тестирования...

 cleanup_and_archive:
   runs-on: ubuntu-latest
   needs: build_and_test # Запускать только после успешной сборки
   steps:
     - name: Checkout repository
       uses: actions/checkout@v3

     - name: Sanitize workspace and create backup
       run: |
         chmod +x./scripts/project-hygiene.sh
         ./scripts/project-hygiene.sh --type=tar --dest=./artifacts

     - name: Upload clean project backup
       uses: actions/upload-artifact@v3
       with:
         name: clean-project-backup
         path:./artifacts/*.tar.gz

Такая интеграция полностью автоматизирует процесс, как и было запрошено, создавая чистый артефакт сборки после каждой успешной итерации.
________________


Заключение: План устойчивой гигиены проекта




Краткое изложение решения


Представленная система предлагает комплексное решение проблемы беспорядка в проекте, основанное на архитектуре "команды агентов". В ее основе лежит декларативный манифест .projectclean, который служит единым источником истины для всех операций. Специализированные агенты — Агент Санации (использующий безопасный паттерн инверсии rsync) и Агент Архивист (эффективно использующий tar или zip) — выполняют свои задачи согласованно, руководствуясь этим манифестом. Вся система оркестрируется мастер-скриптом project-hygiene.sh, в ядро которого встроена критически важная функция "пробного запуска" для максимальной безопасности.


За пределами одного проекта


Важно подчеркнуть, что предложенная структура — это не одноразовое решение для конкретного проекта, а многоразовый, масштабируемый шаблон (blueprint). Скрипт project-hygiene.sh и концепция манифеста могут быть легко адаптированы и развернуты в множестве проектов, устанавливая единый, общеорганизационный стандарт гигиены. Это позволяет унифицировать подходы к управлению артефактами, упростить онбординг новых сотрудников и повысить общую инженерную культуру.


Долгосрочная ценность


Внедрение такой системы приносит непрерывные дивиденды на протяжении всего жизненного цикла проекта. Стратегические преимущества включают ускорение циклов разработки за счет уменьшения когнитивной нагрузки на разработчиков, снижение количества ошибок, связанных с устаревшими или временными файлами, а также создание более компактных и быстрых резервных копий. В конечном счете, это повышает уверенность команды в целостности и качестве своего проекта, создавая устойчивую и эффективную среду для разработки.
Источники
   1. How to deal with cluttered/bloated project files? Help! : r/unrealengine - Reddit, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   2. Projclean: project dependencies & build artifacts cleanup tool, recursively cleans node_modules, target, build, and more : r/commandline - Reddit, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   3. How to programmatically detect whether rsync detected changes or not (Linux, command line, bash, rsync, admin) - Quora, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   4. Please also consider a --dry-run option that gives a preview of what actions wou... | Hacker News, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   5. Configure cleanup policies | Artifact Registry documentation - Google Cloud, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   6. gitlab ci - Remove artifacts from CI manually - Stack Overflow, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   7. .gitignore file - ignoring files in Git | Atlassian Git Tutorial, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   8. gitignore Documentation - Git, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   9. Ignoring files - GitHub Docs, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   10. A collection of useful .gitignore templates - GitHub, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   11. What files can I delete from my project folder? - Game Development Stack Exchange, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   12. .gitignore Command Guide: Practical Examples and Terraform Tips | env zero, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   13. Gitignore pattern confusion : r/git - Reddit, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   14. GNU tar 1.35: 6.4 Excluding Some Files, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   15. How to Exclude Files and Directories When Creating a tar.gz File - GeeksforGeeks, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   16. dotnet clean command - .NET CLI | Microsoft Learn, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   17. Implementing dry-run in bash scripts - Server Fault, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   18. Add some dry run option to script - Unix & Linux Stack Exchange, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   19. How to Exclude Files and Directories When Creating a tar.gz File | Baeldung on Linux, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   20. Shell command to tar directory excluding certain files/folders - Codemia, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   21. Linux Tar Zip Exclude Directory - Hash Interactive, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   22. Creating a .zip File - JMU CS Wiki, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   23. ZIP command in Linux with examples - GeeksforGeeks, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]
   24. How can I create a zip archive of a whole directory via terminal without hidden files?, дата последнего обращения: сентября 21, 2025, [URL_REMOVED]