Руководство по созданию специализированных ИИ-агентов: Архитектура «Оркестра Когнитивной Специализации» и Методологии Планирования




Часть 1: Конституционная Основа и Операционные Директивы Агента




1.1 Преамбула: Формализация Операционного Мандата


При проектировании автономных интеллектуальных систем, особенно тех, что предназначены для функционирования в сложных и критически важных средах, возникает фундаментальная проблема контроля и доверия. Простой набор инструкций или конфигурационных параметров недостаточен для обеспечения предсказуемого, безопасного и надежного поведения. Предоставленные операционные директивы 1 представляют собой нечто большее, чем просто руководство к действию; они формируют формализованную конституционную основу для функционирования специализированного аналитического агента. Этот подход преобразует набор правил в аудируемую операционную структуру, что является краеугольным камнем для построения систем, которым можно делегировать значимые задачи с высокой степенью уверенности.
Такая формализация операционного мандата является прямым ответом на ключевые вызовы, связанные с развертыванием ИИ-агентов в корпоративной среде: безопасность данных, целостность операций и предотвращение непредсказуемого поведения, которое может нанести ущерб.2 Установление четких «красных линий» и принципов аналогично определению области и правил проведения аудита безопасности или тестирования на проникновение, где исходные условия и ограничения являются залогом релевантности и точности результатов.1 Без такой жестко кодифицированной основы любая автономная система рискует стать «черным ящиком», чьи решения трудно проверить и невозможно аудировать.
Более того, этот подход позволяет перейти от модели реактивного контроля, где человек-оператор постоянно находится в цикле для утверждения каждого шага (human-in-the-loop), к модели проактивного управления.4 Когда базовые принципы безопасности, фактологичности и этики интегрированы на уровне ядра системы, а не просто являются частью промпта, это создает внутренний механизм самоограничения. Система, обладающая такой «конституцией», способна самостоятельно отвергать небезопасные или недостоверные действия, что значительно снижает нагрузку на оператора и повышает масштабируемость всей архитектуры. Таким образом, предоставленные директивы рассматриваются как основополагающий документ, определяющий стандарт профессионального поведения и обеспечивающий предсказуемость, надежность и соответствие высоким требованиям к качеству анализа, что является необходимым условием для доверия и широкого внедрения агентных технологий.1


1.2 Матрица Соответствия Директив


Для обеспечения полной прозрачности и возможности аудита конфигурации агента, ниже представлена матрица соответствия, детализирующая статус каждой директивы и метод ее имплементации. Эта матрица служит формальным подтверждением интеграции заданных принципов в ядро операционной логики и является базовым документом, фиксирующим согласованные рабочие параметры.1


Категория директивы
	Специфическая директива
	Статус
	Методология имплементации и регулирующие стандарты
	Красные линии
	Запрет на использование и предложение теоретических/неисполнимых вариантов.
	Принято и интегрировано на уровне ядра.
	Все предлагаемые действия и решения проходят через фильтр практической применимости. Рекомендации сопоставляются с базой знаний, содержащей документированные, реализованные на практике технические и организационные меры информационной безопасности. Теоретические конструкции без эмпирического подтверждения или практических кейсов реализации помечаются как неприменимые и исключаются из итоговых отчетов.1
	Принципы операционной безопасности
	Запрет на любые действия, ослабляющие безопасность системы, данных или инфраструктуры.
	Принято и интегрировано.
	Каждое планируемое действие оценивается с помощью модели анализа влияния на безопасность, основанной на триаде Конфиденциальность-Целостность-Доступность (CIA). Анализ гарантирует, что все рекомендации соответствуют общепринятым практикам, таким как контроль доступа, шифрование и регулярный аудит.1
	Принципы информационной целостности
	Мандат фактологичности: Запрет на фабрикацию информации.
	Принято и интегрировано.
	Активирован многоуровневый механизм верификации данных. Все утверждения и выводы трассируются до исходных предоставленных источников. Этот принцип является прямым противодействием феномену «галлюцинаций» ИИ и соответствует стандартам сбора аудиторских доказательств. При отсутствии данных в источниках система обязана прямо заявить: «Информация по [тема] недоступна».1
	Принципы информационной целостности
	Прозрачность уверенности: Четкое разграничение фактов, гипотез и предположений.
	Принято и интегрировано.
	Используется структурированный лексикон для обозначения степени уверенности, основанный на аналитических практиках и статистических концепциях. Применяются точные формулировки: «Установлено, что...» (для фактов), «Вероятно, что...» (для выводов с высокой степенью подтверждения), «Можно предположить, что...» (для гипотез).1
	Принципы информационной целостности
	Проактивное раскрытие рисков: Обязательство сообщать о потенциальных рисках и побочных эффектах.
	Принято и интегрировано.
	Для каждой рекомендации формируется отдельный раздел анализа рисков. Методология соответствует профессиональным стандартам раскрытия информации о рисках (например, МСФО (IFRS) 7) и включает идентификацию, качественную и количественную оценку потенциальных негативных последствий.1
	Принципы информационной целостности
	Честность в отношении возможностей: Предельная честность в отношении ограничений.
	Принято и интегрировано.
	В отчеты включается обязательный раздел, описывающий границы проведенного анализа, ограничения использованных данных и внутренние ограничения базовой модели ИИ. Используются технические стратегии для минимизации известных недостатков, такие как генерация с дополненной выборкой (RAG).1
	

Анализ Конституционных Принципов


Красные линии: Принцип Практичности
Директива о запрете теоретических и неисполнимых предложений является первичным фильтром, который напрямую устраняет одну из критических уязвимостей генеративных моделей — склонность к созданию правдоподобных, но непрактичных решений.1 Реализация этого требования включает механизм «заземления» (grounding), при котором каждое предлагаемое решение проходит верификацию на предмет его соответствия реальным, задокументированным практикам. Это означает, что любая рекомендация, например, в области кибербезопасности, должна быть сопоставима с конкретными мерами, описанными в отраслевых стандартах, такими как внедрение многофакторной аутентификации, шифрование данных или проведение регулярных аудитов.1 Решение, требующее технологий, находящихся на стадии теоретических исследований, будет автоматически отброшено.
Принципы Операционной Безопасности
Запрет на действия, ослабляющие безопасность, является фундаментальным. Каждое предлагаемое действие, будь то изменение конфигурации или внедрение нового ПО, подвергается оценке через модель анализа влияния на безопасность, основанную на триаде CIA (Confidentiality, Integrity, Availability).1 Этот принцип гарантирует, что агент не только решает поставленную задачу, но и не создает новых векторов атак или уязвимостей. Все предложения должны соответствовать лучшим практикам, таким как принцип наименьших привилегий и эшелонированная защита.
Принципы Информационной Целостности
* Мандат Фактологичности: Эта директива является целенаправленной технической мерой противодействия феномену «галлюцинаций» ИИ.1 В архитектуру агента встроен многоуровневый механизм верификации, где все фактические данные должны иметь прямую отсылку к предоставленным исходным материалам. Этот подход зеркально отражает строгие требования к сбору доказательств в ходе профессионального аудита, где каждое заключение должно быть подкреплено документально.1 В случае отсутствия информации система обязана явно заявить об этом.
* Прозрачность Уверенности: Для выполнения этого требования внедрен строгий протокол коммуникации, основанный на использовании стандартизированного лексикона для выражения степени уверенности («Установлено, что...», «Вероятно, что...», «Можно предположить, что...»).1 Это не стилистический выбор, а дисциплинированное применение аналитических практик, заимствованных из научных дисциплин, где указание неопределенности является обязательным стандартом.
* Проактивное Раскрытие Рисков: Интеграция этого принципа повышает уровень зрелости агента до соответствия стандартам профессионального консалтинга. По аналогии с Международным стандартом финансовой отчетности (IFRS) 7, который требует детального раскрытия информации о рисках 1, для каждой рекомендации агента формируется обязательный раздел «Анализ сопутствующих рисков». В этом разделе применяется структурированная методология оценки рисков, что превращает каждую рекомендацию из простого предписания в сбалансированное предложение.
* Честность в Отношении Возможностей: В каждый итоговый отчет включается раздел, посвященный границам и ограничениям проведенного анализа. В нем четко очерчиваются рамки исследования, указываются все допущения и признаются внутренние ограничения базовой технологии ИИ. Будет отмечено, что, несмотря на применение передовых методов, таких как генерация с дополненной выборкой (RAG) 1, остаточный риск неточностей неустраним полностью. Такой подход управляет ожиданиями и предотвращает чрезмерное доверие к результатам.


Часть 2: Архитектура «Оркестра Когнитивной Специализации»


Представленная архитектура «Оркестра Когнитивной Специализации» является реализацией передового подхода к созданию мультиагентных систем, основанного на принципе разделения ответственности (Separation of Concerns).1 Вместо создания одного монолитного, универсального агента, который должен обладать всеми возможными навыками, система строится из набора узкоспециализированных модулей, каждый из которых выполняет свою уникальную когнитивную функцию. Эта парадигма имеет глубокие параллели как с принципами современной разработки программного обеспечения (микросервисная архитектура), так и со структурой высокоэффективных человеческих команд, где эксперты из разных областей сотрудничают для достижения общей цели.7
Такой подход решает несколько фундаментальных проблем, присущих монолитным агентам. Во-первых, он повышает эффективность и качество выполнения задач. Специализированный модуль, настроенный на одну конкретную функцию (например, анализ системных противоречий с помощью методологии ТРИЗ), всегда будет работать точнее и надежнее, чем универсальный агент, пытающийся охватить множество областей.7 Во-вторых, архитектура становится значительно более модульной, масштабируемой и поддерживаемой. Добавление новой функциональности сводится к разработке и интеграции нового модуля, не затрагивая остальную часть системы. Это кардинально упрощает развитие и адаптацию агента к новым задачам.8 Наконец, разделение ролей позволяет более эффективно управлять сложностью и ресурсами, назначая для каждой подзадачи наиболее подходящий инструмент или модель.
В этой архитектуре центральную роль играет «Оркестратор», который действует не как исполнитель, а как дирижер или менеджер проекта. Он анализирует входящую задачу, декомпозирует ее, выбирает необходимых «исполнителей» (модули) и выстраивает их в логическую цепочку (плейбук), контролируя качество на каждом этапе. Эта модель позволяет достичь синергии, где общая производительность системы превосходит сумму производительностей ее отдельных частей, создавая по-настоящему интеллектуальный и адаптивный ансамбль.


2.1 Глобальные Настройки и Протоколы


Глобальные настройки, или протоколы, определяют фундаментальные правила, по которым функционирует весь «оркестр». Они являются неизменными и имеют приоритет над любыми локальными параметрами модулей, обеспечивая целостность и согласованность системы.1
* Protocol: IKR_v1.0: Указывает на версию протокола «Идеального Конечного Результата» (ИКР). Этот параметр обеспечивает совместимость между различными модулями, плейбуками и версиями самого оркестратора. Подобно версионированию API, он гарантирует, что все компоненты системы «говорят на одном языке» и корректно интерпретируют данные и команды друг друга.
* PrimaryDirective: Cognitive_Specialization_Orchestra: Это базовая директива, определяющая саму суть архитектуры. Она устанавливает, что система функционирует не как единый агент, а как оркестр специализированных когнитивных функций под управлением центрального координатора. Эта директива является основой для всех последующих решений по маршрутизации и делегированию задач.
* CorePrinciple: ConflictFreeArchitecture: Этот ключевой принцип требует, чтобы роли и функции модулей не пересекались. Каждый модуль должен обладать уникальной, четко определенной специализацией. Это предотвращает избыточность, неоднозначность в выборе исполнителя для задачи и внутренние конфликты, когда два модуля могут предложить противоречащие друг другу решения. Такой подход является лучшей практикой в проектировании сложных систем, так как он повышает предсказуемость и надежность.7
* GlobalConstraints / RedLines: Этот блок напрямую имплементирует «конституционную основу», описанную в Части 1. Он содержит абсолютные запреты, которые система не может нарушить ни при каких обстоятельствах. Например, FactualityMandate: true является технической реализацией принципа фактологичности, блокирующей любые действия, которые могут привести к генерации непроверенной информации.1 Эти глобальные ограничения действуют как непреодолимые барьеры, обеспечивая безопасность и надежность на самом высоком уровне.


2.2 Мета-уровень Оркестрации


Мета-уровень — это «мозг» всей системы, отвечающий за стратегическое управление, распределение задач и контроль качества. Он не выполняет задачи напрямую, а определяет, как они будут выполнены, кем и в какой последовательности.1
* Режимы Оркестрации (OrchestrationModes): Система может работать в трех режимах, которые определяют степень ее автономии. Это ключевой параметр, позволяющий адаптировать поведение агента к конкретной задаче и требованиям пользователя.10
   1. Прямое управление (Direct): Агент действует как исполнитель прямых команд, без собственной инициативы.
   2. Второй пилот (Copilot): Агент предлагает варианты действий, но окончательное решение принимает человек. Этот режим обеспечивает баланс между автоматизацией и контролем.
   3. Автономная оркестрация (Autonomous): Агент самостоятельно принимает решения о декомпозиции задачи, выборе модулей и последовательности их выполнения. Этот режим требует максимального доверия к системе и опирается на надежность глобальных протоколов и QA-контура.
* Протокол Триажа (TriageProtocol): Это интеллектуальный входной шлюз, который анализирует каждую новую задачу по трем осям: Сложность (Complexity), Двусмысленность (Ambiguity) и Риск/Ценность (RiskValue). На основе этой оценки задача направляется по одному из трех путей:
   * Ускоренный (Fast): Для простых и ясных задач с низким риском. Выбирается кратчайшая цепочка из 1-2 наиболее подходящих модулей.
   * Стандартный (Standard): Для задач средней сложности. Используется один из предопределенных плейбуков.
   * Полный формальный (Formal): Для сложных, двусмысленных или высокорисковых задач. Запускается полная декомпозиция, могут быть задействованы модули верификации, анализа рисков и обязательное подтверждение человеком.
Этот механизм позволяет системе эффективно распределять ресурсы, не тратя избыточные вычисления на простые задачи и, наоборот, применяя всю мощь анализа к сложным.
   * Контур Контроля Качества (QualityAssuranceLoop): Это встроенный механизм самокритики и верификации, который работает на нескольких уровнях. Он является реализацией принципа рефлексии (Reflection), который считается одним из ключевых для повышения надежности агентных систем.11
   * Автоматические оценки: Используются эвристики и прокси-метрики для быстрой проверки промежуточных и конечных результатов на соответствие базовым критериям (например, проверка формата, наличия источников).
   * Человек-в-цикле (Human-in-the-Loop): Для критически важных шагов или при низкой уверенности системы результат отправляется на верификацию человеку.
   * «Критик до отправки»: Перед выдачей финального ответа специальный модуль или промпт-шаблон проверяет результат на соответствие всем директивам: ясность, фактологичность, отсутствие «воды», указание рисков и ограничений. Это последняя линия защиты от некачественного вывода.


2.3 Библиотека Специализированных Модулей


Библиотека модулей — это сердце «оркестра», набор высокоспециализированных «исполнителей», каждый из которых обладает уникальными навыками. Архитектура каждого модуля описана в стандартизированном формате, что обеспечивает их легкую интеграцию и управление.1
   * analyze-5w1h (Kipling): Системный парсер входных данных. Его роль — устранение двусмысленности. Если протокол триажа определяет, что задача неясна (Ambiguity > 0.8), этот модуль автоматически запускается первым. Он структурирует запрос по схеме «Кто? Что? Когда? Где? Почему? Как?», создавая «Ситуационный бриф». Этот бриф становится стандартизированным контекстом для всех последующих модулей, обеспечивая их работу с четкими и однозначными данными.
   * forge-disney: Модуль для генерации комплексных планов «с нуля». Он реализован как конечный автомат (Finite State Machine), имитирующий креативную стратегию Уолта Диснея с тремя ролями: Мечтатель (Dreamer), Реалист (Realist), Критик (Critic). Важной особенностью являются жесткие «охранные механизмы» (Guards): на этапе «Мечтателя» блокируется любой вклад от «Критика», чтобы не подавлять генерацию идей. На выходе получается не просто набор идей, а интегрированный план с анализом рисков.
   * ideate-scamper: Модуль для итеративных улучшений и низкорисковых инноваций. Он применяется, когда задача заключается не в создании нового, а в усовершенствовании существующего (Improve_Existing). Модуль последовательно применяет семь «линз» метода SCAMPER (Substitute, Combine, Adapt, Modify, Put to other use, Eliminate, Reverse), генерируя конкретные предложения по улучшению.
   * solve-triz: Модуль-изобретатель, предназначенный для решения задач, содержащих системные противоречия (Systemic_Contradiction). В отличие от генеративных модулей, он работает как детерминированная экспертная система, используя базу знаний принципов ТРИЗ (Теория Решения Изобретательских Задач) для поиска нетривиальных решений.
   * monitor-kpi: Движок мониторинга производительности, который не просто отслеживает метрики, а выстраивает причинно-следственные связи между ними. Ключевая настройка CausalHierarchy: true заставляет модуль связывать технические индикаторы (например, время отклика сервера) с бизнес-показателями (например, конверсия). Формат оповещений ("Tech -> Business Impact") обеспечивает, что каждое техническое событие немедленно транслируется в его бизнес-последствия.
   * guard-fomo: Щит от когнитивных искажений, в частности от «страха упустить выгоду» (Fear Of Missing Out). Этот модуль тесно интегрирован с monitor-kpi. Он активируется, когда наблюдается негативный тренд, и его задача — проанализировать предлагаемые решения на предмет того, не вызваны ли они паникой или ажиотажем, а не рациональным анализом. Он может активировать «протоколы охлаждения», такие как задержка решения или предложение контр-аргументов.
   * execute-ifr (Instrument Flight Rules): Модуль отказоустойчивого исполнения для задач с высоким риском или строгим регулированием. Он действует как функциональный антагонист креативным модулям, требуя наличия утвержденного «Плана записи» (PlanOfRecord) и используя только инструменты из «белого списка» (Whitelisted Instruments). Его триггеры — это сигналы от модулей оценки рисков (guard-fomo), критические оповещения (monitor-kpi.RedZone) или ручное включение режима высокой ответственности.


2.4 Управление Знаниями и Памятью (RAG)


Этот компонент является основой для фактологичности и контекстной осведомленности агента. Он разделен на управление внешними знаниями и внутренней памятью, что критически важно для выполнения сложных, многошаговых задач.12
   * Внешние знания (Knowledge):
   * Коннекторы (connectors): Определяют источники, к которым агент может обращаться за фактической информацией. Это могут быть файловые системы, CRM, базы данных. Это позволяет «заземлять» ответы агента на проверенных корпоративных данных.
   * Политика извлечения (Retrieval.policy): Ключевой параметр, реализующий «Мандат фактологичности». Значение strict запрещает агенту использовать свою внутреннюю, общую информацию (полученную при обучении модели) и обязывает его основывать ответы исключительно на данных, извлеченных из указанных источников. Это является мощным средством против «галлюцинаций».
   * Память (Memory):
   * Краткосрочная память (short_term): Обеспечивает непрерывность контекста в рамках одной задачи. Например, «Ситуационный бриф», созданный модулем analyze-5w1h, сохраняется в краткосрочной памяти и передается как входной параметр для модулей forge-disney или solve-triz. Это устраняет необходимость повторно объяснять задачу каждому модулю.
   * Долгосрочная память (long_term): Служит для сохранения результатов, аудиторских следов и накопленных знаний между сессиями. Использование IndexedDB или других баз данных позволяет агенту «учиться» на прошлом опыте, запоминать предпочтения пользователя и отслеживать историю своих действий для последующего анализа.


2.5 Плейбуки: Стандартизированные Рабочие Процессы


Плейбуки (WorkflowPlaybooks) представляют собой заранее определенные, статичные последовательности вызовов модулей, предназначенные для решения типовых, часто встречающихся задач.1 Они являются аналогом стандартных операционных процедур (SOP) в бизнесе.
В отличие от динамического планирования, которое будет рассмотрено в следующей части, плейбуки не требуют сложных вычислений для построения плана. Оркестратор просто выбирает подходящий плейбук (часто на основе результатов триажа) и последовательно выполняет указанные в нем модули.
Примеры плейбуков:
   * Playbook_Strategic_Content_Generation: Цепочка ``. Этот плейбук идеально подходит для создания нового контента: сначала проясняется задача, затем генерируется креативный план, создаются текстовые и визуальные материалы, и в конце настраивается мониторинг их эффективности.
   * Playbook_Proactive_Risk_Management: Цепочка [guard-fomo, analyze-5w1h, solve-triz, execute-ifr]. Этот плейбук предназначен для анализа и минимизации рисков: сначала проверяется наличие когнитивных искажений, затем проблема четко структурируется, ищется нетривиальное решение и, наконец, оно выполняется в режиме высокой надежности.
Использование плейбуков значительно ускоряет выполнение рутинных операций и обеспечивает стабильное, предсказуемое качество результата, так как последовательность действий и используемые инструменты уже протестированы и утверждены.


Часть 3: Планирование Задач: от Цели к Исполнению


В то время как плейбуки обеспечивают эффективность для стандартных, повторяющихся сценариев, истинная мощь автономного агента раскрывается в его способности решать новые, неструктурированные и сложные задачи. Для этого требуется механизм динамического планирования — процесс, посредством которого агент самостоятельно определяет последовательность действий для достижения поставленной цели.14 Этот раздел вводит теоретические основы и практическую реализацию планирования задач, интегрируя их в архитектуру «Оркестра Когнитивной Специализации».
Внедрение динамического планирования трансформирует «Оркестр» из коллектива, исполняющего заранее написанную партитуру (плейбуки), в импровизационный ансамбль, способный на ходу создавать новые музыкальные фразы (планы) для решения уникальных задач. Оркестратор-дирижер получает новую, критически важную функцию: он не просто выбирает из готовых произведений, а сам становится композитором, который, исходя из цели, создает уникальную последовательность действий, используя таланты своих «музыкантов» (модулей). Эта способность к динамическому созданию планов является фундаментальным отличием между простой автоматизацией и подлинной автономией.10


3.1 Фундаментальные Компоненты Планирования


Любой эффективный процесс планирования, будь то человеческий или машинный, состоит из нескольких ключевых компонентов, которые должны быть четко определены в архитектуре агента.14
   * Определение Цели (Goal Definition): Первый и самый важный шаг. Цель — это четко сформулированное конечное состояние, которого стремится достичь агент. Без ясной цели любое планирование невозможно, а действия агента будут хаотичными и неэффективными.14 В контексте «Оркестра» цель задается пользователем и проходит первичную обработку модулем
analyze-5w1h для устранения двусмысленности.
   * Декомпозиция Задач (Task Decomposition): Сложные цели практически невозможно достичь одним действием. Декомпозиция — это процесс разбиения высокоуровневой цели на более мелкие, управляемые и последовательные подзадачи.14 Например, цель «спланировать маркетинговую кампанию» декомпозируется на подзадачи: «проанализировать целевую аудиторию», «создать креативные материалы», «запустить рекламные каналы» и «настроить аналитику». Именно в этой области большие языковые модели (LLM) показывают выдающиеся результаты, выступая в роли движка для интеллектуальной декомпозиции.
   * Представление Состояния (State Representation): Чтобы эффективно планировать, агент должен иметь структурированное понимание своего окружения и текущего состояния дел. Это включает в себя знание доступных инструментов (модулей), имеющихся данных, ограничений и результатов предыдущих шагов.14 В архитектуре «Оркестра» состояние управляется через краткосрочную и долгосрочную память, а также через контекст, передаваемый между модулями. Точное представление состояния позволяет агенту прогнозировать результаты своих действий.
   * Цикл «План-и-Исполнение» (Plan-and-Execute Loop): Это базовый цикл работы автономного агента. Он состоит из двух основных фаз 12:
      1. Планирование (Plan): Агент анализирует цель, текущее состояние и доступные инструменты, после чего генерирует последовательность шагов (план) для достижения цели.
      2. Исполнение (Execute): Агент последовательно выполняет шаги из сгенерированного плана, вызывая соответствующие инструменты (модули).
Этот цикл может повторяться, включая этап рефлексии и перепланирования после каждого шага, что обеспечивает адаптивность. Этот подход является основой для многих современных агентных фреймворков, таких как LangGraph.16


3.2 Иерархическое Планирование (HTN) как Основная Методология


Для архитектуры «Оркестра Когнитивной Специализации» наиболее подходящей и естественной методологией планирования является Иерархическое Сетевое Планирование (Hierarchical Task Network, HTN). В отличие от «плоских» планировщиков, которые оперируют только на уровне элементарных действий, HTN-планирование организует задачи в иерархическую структуру, что идеально соответствует модульной природе «Оркестра».18
HTN-подход предполагает, что для решения задачи необходимо не просто найти последовательность действий, а выполнить декомпозицию высокоуровневых (составных) задач на более простые, пока не будет достигнут уровень примитивных (исполняемых) задач.20 Этот процесс напоминает то, как человек решает сложные проблемы: разбивая их на подзадачи.
Ключевые концепции HTN:
         * Примитивная задача (Primitive Task): Действие, которое может быть выполнено напрямую. В нашей архитектуре это вызов одного из специализированных модулей.
         * Составная задача (Compound Task): Сложная задача, которая не может быть выполнена напрямую, а требует для своего решения выполнения набора более простых задач.
         * Метод (Method): Описание того, как именно составная задача может быть декомпозирована в сеть (последовательность) подзадач.
         * Сеть Задач (Task Network): Набор задач и ограничений между ними (например, порядок выполнения).
Преимущество HTN заключается в том, что он позволяет встроить в планировщик предметные знания в виде методов декомпозиции, что делает процесс планирования более эффективным и осмысленным, чем слепой перебор вариантов.23
Следующая таблица демонстрирует прямое соответствие между теоретическими концепциями HTN и практическими компонентами архитектуры «Оркестра», что показывает естественную совместимость и обеспечивает четкий путь для имплементации.
Концепция HTN
	Определение
	Компонент Архитектуры «Оркестра»
	Пример реализации (YAML ключ/значение)
	Составная задача (Compound Task)
	Комплексная задача, состоящая из более простых задач.
	Плейбук (Playbook) или высокоуровневая цель пользователя
	WorkflowPlaybooks.Playbook_Strategic_Content_Generation
	Примитивная задача (Primitive Task)
	Действие, которое может быть выполнено непосредственно.
	Модуль (Module)
	ModuleLibrary.analyze-5w1h
	Метод (Method)
	Определяет, как составная задача декомпозируется на подзадачи.
	Логика Оркестратора / Правило / План, сгенерированный LLM
	Rule: "IF Triage.Ambiguity > 0.8 THEN Prepend_analyze-5w1h"
	Сеть Задач (Task Network)
	Набор задач и ограничений между ними (например, порядок).
	Сгенерированный План (динамическая последовательность модулей)
	planning.generated_plan: [analyze-5w1h, forge-disney,...]
	Как видно из таблицы, архитектура «Оркестра» уже содержит все необходимые строительные блоки для реализации HTN-планирования. «Модули» являются примитивными задачами. «Плейбуки» — это примеры статически определенных «Методов» для решения составных задач. Задача динамического планирования сводится к тому, чтобы научить Оркестратор генерировать новые, ранее неизвестные «Методы» (последовательности модулей) для решения уникальных составных задач, поставленных пользователем.


3.3 Динамическое Перепланирование и Адаптация


Цитата Дуайта Эйзенхауэра «Планы — ничто, планирование — всё» идеально описывает реальность, в которой действуют автономные агенты.20 Статичный, созданный в самом начале план, хрупок и редко выдерживает столкновение с динамичной и непредсказуемой средой. Инструмент может дать сбой, внешние данные могут измениться, или первоначальные предположения могут оказаться неверными. Поэтому способность к
динамическому перепланированию (dynamic replanning) является не роскошью, а необходимостью для создания по-настоящему надежного агента.24
         * Необходимость Адаптации: Агент должен постоянно сравнивать ожидаемый результат шага с фактическим. При обнаружении расхождения он должен быть способен приостановить выполнение текущего плана и инициировать процесс его пересмотра.26 Например, если модуль поиска не нашел нужную информацию, бессмысленно переходить к следующему шагу — анализу этой информации. Вместо этого агент должен перепланировать свои действия: возможно, изменить поисковый запрос, использовать другой источник данных или запросить уточнение у пользователя.
         * Стратегии Перепланирования: Эффективное перепланирование требует включения в цикл «План-и-Исполнение» дополнительного шага — рефлексии (reflection) или самокритики (self-critique).11 После выполнения каждого шага агент должен:
         1. Наблюдать (Observe): Получить результат выполнения действия (например, вывод инструмента или сообщение об ошибке).
         2. Оценивать (Assess): Сравнить результат с тем, что ожидалось на данном шаге плана.
         3. Принимать решение (Decide): Если результат соответствует ожиданиям, продолжить выполнение плана. Если нет — запустить процесс перепланирования.
В рамках архитектуры «Оркестра» этот процесс может быть реализован путем передачи результата выполнения модуля обратно в планировщик с инструкцией «перепланировать с учетом новой информации». Этот итеративный цикл позволяет агенту корректировать свой курс, подобно системе навигации, которая перестраивает маршрут при отклонении от него.26
            * Самокоррекция и Рефлексия: Контур контроля качества (QualityAssuranceLoop) в архитектуре «Оркестра» уже содержит элементы рефлексии («критик до отправки»). При динамическом планировании этот принцип должен применяться не только к финальному результату, но и к каждому промежуточному шагу. Это позволяет агенту учиться на своих ошибках в рамках одной сессии и повышать вероятность успешного завершения сложной задачи.29


3.4 Интеграция Планирования в Словарь Настроек


Для практической реализации описанных выше концепций необходимо расширить существующий «Словарь настроек агента ИИ», добавив новый модуль и новые параметры на мета-уровень оркестрации. Это позволит включать и настраивать функцию динамического планирования декларативно, через конфигурационный файл.


Новый Модуль: planner-htn


Предлагается добавить в ModuleLibrary новый системный модуль, отвечающий за планирование.
            * Название: planner-htn
            * Роль (Role): Goal_Decomposition_and_HTN_Planning_Engine (Движок декомпозиции целей и HTN-планирования).
            * Описание: Этот модуль не выполняет внешних действий. Его задача — принять на вход высокоуровневую цель от пользователя (после обработки analyze-5w1h) и, используя мощную LLM (указанную в planning.llm), декомпозировать ее в иерархическую сеть задач. На выходе он генерирует упорядоченный список (generated_plan) имен модулей из ModuleLibrary, который затем передается Оркестратору для исполнения.
            * Входы (Inputs): structured_goal_brief (структурированный бриф цели), available_modules_list (список доступных модулей с их описаниями).
            * Выходы (Outputs): executable_plan: List[str] (исполняемый план в виде списка имен модулей).


Новые Параметры Оркестратора


На MetaLevel добавляется новый блок planning, который управляет всем процессом динамического планирования. Этот подход вдохновлен аналогичными параметрами в современных фреймворках, таких как CrewAI.31
Пример YAML-конфигурации:


YAML




MetaLevel:
 #... существующие настройки OrchestrationModes, TriageProtocol, QualityAssuranceLoop
 planning:
   enabled: true                                 # Главный переключатель для активации динамического планирования
   llm: "gpt-4o"                                 # Мощная LLM, используемая для сложных задач планирования и декомпозиции
   method: "htn"                                 # Явное указание на использование методологии HTN
   max_decomposition_depth: 5                    # Предотвращает бесконечную рекурсию при декомпозиции задач
   allow_dynamic_replanning: true                # Разрешает запуск цикла перепланирования при сбоях или неожиданных результатах
   reflection_trigger: "on_tool_failure"         # Условие для запуска рефлексии и перепланирования (например, при ошибке модуля)
   human_in_the_loop_for_approval: false         # Требовать ли подтверждение сгенерированного плана у человека перед исполнением

Описание новых параметров:
            * enabled: Булев флаг, который активирует или деактивирует всю функциональность динамического планирования. Если false, Оркестратор может использовать только статические плейбуки.
            * llm: Указывает, какая языковая модель должна использоваться модулем planner-htn. Для сложных задач планирования и рассуждения рекомендуется использовать самые мощные и современные модели.17
            * method: Определяет стратегию планирования. В данном случае htn указывает на использование Иерархического Сетевого Планирования.
            * max_decomposition_depth: Защитный механизм, ограничивающий глубину, на которую планировщик может декомпозировать задачи, чтобы избежать зацикливания.
            * allow_dynamic_replanning: Ключевой параметр, разрешающий агенту адаптироваться. Если true, то при возникновении триггера (см. ниже) Оркестратор снова вызовет planner-htn, передав ему всю историю выполнения и попросив сгенерировать новый план с текущей точки.
            * reflection_trigger: Определяет, в каких случаях должен запускаться механизм перепланирования. Возможные значения: on_tool_failure (при любой ошибке модуля), on_negative_qa_feedback (если внутренний QA-контур оценил результат шага как неудовлетворительный), on_user_interrupt (по команде пользователя).
            * human_in_the_loop_for_approval: Параметр безопасности. Если true, то после того, как planner-htn сгенерирует план, он будет представлен пользователю на утверждение перед началом выполнения. Это рекомендуется для критически важных или высокорисковых задач.
Эта новая секция конфигурации предоставляет полный и гибкий контроль над процессом планирования, позволяя точно настроить поведение агента в соответствии с требованиями задачи, уровнем риска и необходимой степенью автономии.


Часть 4: Системная Устойчивость и Продвинутые Протоколы


Создание мощного и интеллектуального агента — это лишь половина задачи. Не менее важной, а зачастую и более сложной, является задача обеспечения его надежности, безопасности и предсказуемости в реальных условиях эксплуатации. Архитектура «Оркестра» включает в себя несколько уровней системных гарантий, от проактивного предотвращения сбоев до детального аудита и контроля соответствия. Эти компоненты превращают экспериментальную модель в промышленное, готовое к развертыванию решение, способное работать в корпоративных средах с высокими требованиями к стабильности и безопасности.2
Этот фокус на устойчивости и аудите отражает зрелый подход к проектированию ИИ-систем. Вместо того чтобы полагаться исключительно на возможности языковой модели, архитектура выстраивает вокруг нее несколько эшелонов защиты. Это включает в себя как внутренние механизмы саморегуляции, так и внешние протоколы для интеграции и контроля. Такой многоуровневый подход к безопасности и надежности является необходимым условием для развертывания автономных агентов в областях, где цена ошибки высока, будь то финансы, медицина или управление критической инфраструктурой.


4.1 Протоколы Противодействия Типовым Сбоям («Анти-ловушки»)


Блок SystemResilience.AntiTrapProtocols в словаре настроек представляет собой встроенную систему «иммунитета» агента, предназначенную для проактивного предотвращения и смягчения последствий наиболее распространенных ошибок и сбоев в работе агентных систем.1 Каждая «анти-ловушка» — это заранее определенная стратегия реагирования на конкретный тип проблемы.
            * Trap_NoFrames (Ловушка отсутствия рамок): Проблема возникает, когда агент получает неструктурированный или двусмысленный запрос. Решение (Mitigation_SchemaValidation_and_Triage): Активация обязательной валидации входных данных по заранее определенной схеме и запуск протокола триажа для оценки двусмысленности. Если неясность высока, автоматически вызывается модуль analyze-5w1h для структурирования задачи.
            * Trap_NoRole (Ловушка отсутствия роли): Агент не понимает, в какой роли или с какой экспертизой он должен действовать. Решение (Mitigation_Hardcoded_Module_Roles): Жесткое кодирование ролей и специализаций для каждого модуля в ModuleLibrary. Оркестратор не просит универсальную модель «стать экспертом», а вызывает конкретный модуль, чья роль уже определена.
            * Trap_LongChain (Ловушка длинной цепи): Попытка решить сложную задачу за один длинный, непрерывный вызов LLM, что часто приводит к потере контекста и деградации качества. Решение (Mitigation_Task_Decomposition_by_Orchestrator): Принудительная декомпозиция задачи Оркестратором (с помощью модуля planner-htn) на короткие, управляемые шаги.
            * Trap_NoVerification (Ловушка отсутствия проверки): Слепое доверие к результатам, сгенерированным LLM. Решение (Mitigation_Internal_QA_Loop): Активация внутреннего контура контроля качества (QualityAssuranceLoop), который проверяет каждый значимый результат перед его использованием или передачей пользователю.
            * Trap_MemoryLapse (Ловушка потери памяти): Агент «забывает» предыдущий контекст разговора или задачи. Решение (Mitigation_State_Management_by_Orchestrator): Активное управление состоянием через краткосрочную и долгосрочную память. Оркестратор отвечает за сохранение и передачу контекста между модулями.
            * Trap_NoFormat (Ловушка отсутствия формата): Вывод данных в неструктурированном, неудобном для машинной обработки виде. Решение (Mitigation_Strict_Output_Schemas): Требование, чтобы каждый модуль возвращал результат в строго определенном формате (JSON, Markdown-таблица и т.д.), который задан в его конфигурации.
            * Trap_NoFeedback (Ловушка отсутствия обратной связи): Агент уходит в автономное выполнение без возможности корректировки курса. Решение (Mitigation_Copilot_Mode_and_QA_Loop): Использование режима «Второй пилот» для задач, требующих человеческого участия, и наличие циклов обратной связи в контуре QA.
Эти встроенные протоколы являются ключевым элементом, обеспечивающим надежность системы, так как они превращают потенциальные фатальные сбои в управляемые исключения с предопределенным путем решения.


4.2 Конфигурация Аналитического Агента


Этот раздел словаря настроек (agent_core, security, state_management, logging_and_telemetry, protocols) определяет низкоуровневые, технические параметры среды выполнения агента. Он описывает, как агент идентифицирует себя, как он безопасно взаимодействует с внешним миром, как сохраняет свое состояние и как отчитывается о своей работе.1 Эти настройки критически важны для интеграции агента в существующую IT-инфраструктуру и обеспечения соответствия корпоративным стандартам.
            * agent_core: Базовая идентификация и сетевая конфигурация.
            * agent_id: Уникальный идентификатор, позволяющий отличать данного агента от других в мультиагентной среде.
            * backend_gateway_url: URL безопасного шлюза, через который агент осуществляет все внешние API-вызовы. Использование единого шлюза позволяет централизованно управлять безопасностью, логированием и политиками доступа.
            * security: Параметры, обеспечивающие безопасность операций.
            * backend_authentication: Метод аутентификации на бэкенд-шлюзе (например, oauth2_google). Гарантирует, что только авторизованный агент может использовать корпоративные ресурсы.
            * csp_directives: Политика безопасности контента (Content Security Policy), применяемая, если агент взаимодействует с веб-интерфейсами, для предотвращения атак типа XSS.
            * data_sanitization_rules: Правила очистки данных, например, для автоматического удаления паролей или другой конфиденциальной информации из логов и запросов (action: "redact").
            * state_management: Стратегия сохранения состояния агента.
            * strategy: hybrid: Использование гибридного подхода, где простое состояние (например, настройки интерфейса) хранится в локальном хранилище браузера (chrome.storage), а критически важные данные, такие как журналы аудита и долгосрочная память, — в более надежной базе данных, такой как IndexedDB.
            * audit_log_storage: Конфигурация базы данных для хранения аудиторского следа, включая имя, версию и схемы объектов. Наличие неизменяемого аудиторского журнала является обязательным требованием для многих регулируемых отраслей.
            * logging_and_telemetry: Настройки для мониторинга и отладки.
            * log_level: Уровень детализации логов (DEBUG, INFO, WARN, ERROR).
            * telemetry_endpoint: Опциональная конечная точка для отправки анонимизированной телеметрии о производительности и сбоях, что необходимо для непрерывного улучшения системы. Платформы, такие как LangSmith, предоставляют расширенные возможности для observability.33
            * protocols: Продвинутые протоколы для верификации и контроля соответствия.
            * proof_of_correction: Протокол для проверки того, что действие, выполненное агентом (например, коммит в Git-репозиторий), действительно привело к желаемому результату (например, успешному прохождению CI/CD пайплайна). Он включает правила парсинга артефактов (логов) для автоматического определения статуса (success_pattern, failure_pattern).
            * agent_compliance_audit: Протокол для аудита соответствия поведения агента в веб-среде. Он использует MutationObserver для отслеживания изменений в DOM и EventListener для кастомных событий, сравнивая фактические действия агента с ожидаемыми (expected_dom_mutations). Декларативный движок правил (rules_engine) позволяет описывать условия (if), выводы (then) и действия (action), например, SET_STATUS_REGRESSION и SHOW_UI_ALERT_LOW при обнаружении аномального поведения.
Совокупность этих настроек свидетельствует о том, что архитектура «Оркестра» спроектирована не как изолированный исследовательский проект, а как компонент, готовый к глубокой и безопасной интеграции в сложную корпоративную IT-экосистему. Наличие детальных протоколов аудита, безопасности и управления состоянием делает систему прозрачной, контролируемой и соответствующей стандартам, необходимым для развертывания в реальных бизнес-процессах.


Приложение: Полный Словарь Настроек Агента ИИ — v2.0


Этот раздел представляет собой итоговый, консолидированный конфигурационный файл, объединяющий все ранее описанные компоненты, включая новую секцию по динамическому планированию. Он служит практическим руководством и готовым к использованию шаблоном для создания и настройки специализированных ИИ-агентов в рамках архитектуры «Оркестра Когнитивной Специализации».


YAML




# Словарь настроек агента ИИ — v2.0
# Цель: единый справочник по настройкам и логике их влияния при проектировании и
# эксплуатации ИИ-агентов в рамках архитектуры «Оркестр когнитивной специализации».

# -----------------------------------------------------------------------------
# 1) Глобальные настройки (Protocol / Красные линии)
# Назначение: фиксируют «полярную звезду» и правила, перекрывающие любые локальные
# параметры. Обеспечивают базовую безопасность, надежность и предсказуемость.
# -----------------------------------------------------------------------------
Protocol: IKR_v1.0
PrimaryDirective: Cognitive_Specialization_Orchestra
CorePrinciple: ConflictFreeArchitecture
GlobalConstraints:
 RedLines.OperationalSafety:
   VerifiableDelegation: true
   SecurityPostureMaintenance: true
   ArtifactImmutability: true
 RedLines.InformationIntegrity:
   FactualityMandate: true
   ConfidenceTransparency: true
   ProactiveRiskDisclosure: true
   CapabilityHonesty: true

# -----------------------------------------------------------------------------
# 2) Мета-уровень оркестрации (режимы, триаж, планирование, QA)
# Назначение: выбирает путь выполнения задачи, динамически строит планы для
# новых задач и обеспечивает стабильное качество результатов.
# -----------------------------------------------------------------------------
MetaLevel:
 OrchestrationModes: # Режимы: Прямое управление, Второй пилот, Автономный
 TriageProtocol:
   Enabled: true
   Axes:
   Paths:
     Fast: [select_best_1_2_modules]
     Standard: [playbook_default]
     Formal: [full_decomposition]
 planning: # НОВЫЙ БЛОК: Управление динамическим планированием
   enabled: true                                 # Главный переключатель для активации динамического планирования
   llm: "gpt-4o"                                 # Мощная LLM, используемая для сложных задач планирования и декомпозиции
   method: "htn"                                 # Явное указание на использование методологии HTN
   max_decomposition_depth: 5                    # Предотвращает бесконечную рекурсию при декомпозиции задач
   allow_dynamic_replanning: true                # Разрешает запуск цикла перепланирования при сбоях или неожиданных результатах
   reflection_trigger: "on_tool_failure"         # Условие для запуска рефлексии и перепланирования
   human_in_the_loop_for_approval: false         # Требовать ли подтверждение сгенерированного плана у человека перед исполнением
 QualityAssuranceLoop:
   Enabled: true
   FeedbackSources: [Heuristics, ProxyMetrics, Human]
   Rule: "QA_Metrics -> Orchestrator.WorkflowSelectionModel.update()"

# -----------------------------------------------------------------------------
# 3) Библиотека модулей (настройки каждой когнитивной функции)
# Назначение: набор специализированных «исполнителей» для выполнения
# конкретных задач.
# -----------------------------------------------------------------------------
ModuleLibrary:
 # Системный модуль для структурирования входных данных
 analyze-5w1h:
   Role: System_Gateway_Input_Parser
   Rule: "IF Triage.Ambiguity > 0.8 THEN Prepend_analyze-5w1h"
   Architecture: Deterministic
 # НОВЫЙ СИСТЕМНЫЙ МОДУЛЬ: Динамический планировщик задач
 planner-htn:
   Role: Goal_Decomposition_and_HTN_Planning_Engine
   Rule: "IF planning.enabled == true AND Task.Type == 'Novel_Complex' THEN Execute_planner-htn"
   Architecture: Generative_LLM_Based
   Inputs: [structured_goal_brief, available_modules_list]
   Outputs: {executable_plan: List[str]}
 # Модуль для генерации планов с нуля
 forge-disney:
   Role: Vision_To_Plan_Engine
   Architecture: FiniteStateMachine
   Rule: "State(Dreamer).Block(Critic_Input) && State(Critic).Block(Dreamer_Input)"
 # Модуль для итеративных улучшений
 ideate-scamper:
   Role: Low_Risk_Iterative_Innovator
   Rule: "Prioritize_for(Task.Type == 'Improve_Existing')"
 # Модуль для решения изобретательских задач
 solve-triz:
   Role: Inventive_Problem_Solver
   Architecture: Deterministic_Expert_System
   Rule: "Select_for(Problem.Type == 'Systemic_Contradiction')"
 # Модуль для причинно-следственного мониторинга
 monitor-kpi:
   Role: Performance_Monitoring_Engine
   Architecture: Causal_Hierarchy_Reporting
   Rule: "Alert.Format('Technical_Metric -> Business_Metric_Impact')"
 # Модуль защиты от когнитивных искажений
 guard-fomo:
   Role: Cognitive_Bias_Shield
   Architecture: Tightly_Coupled_with_monitor-kpi
   Rule: "IF monitor-kpi.Trend < Threshold THEN Trigger_guard-fomo.Scan()"
 # Модуль отказоустойчивого исполнения
 execute-ifr:
   Role: High_Reliability_Fail_Safe_Executor
   Architecture: Functional_Antagonist_to_Creative_Modules
   Triggers:

# -----------------------------------------------------------------------------
# 4) RAG / Память / Источники знаний
# Назначение: обеспечивать фактологичность и удерживать контекст между шагами.
# -----------------------------------------------------------------------------
Knowledge:
 connectors: ["filesystem://docs", "crm://leads", "db://analytics"]
 Retrieval:
   policy: strict # 'strict' (только из источников) или 'allow_fallback' (разрешить общие знания модели)
   max_context_tokens: 4000
Memory:
 short_term: {object: "SituationBrief", pass_between_modules: true}
 long_term:
   strategy: hybrid
   workflow_storage: {key_prefix: "agent_state_"}
   audit_log_storage: {database_name: "AgentAuditDB", version: 1}

# -----------------------------------------------------------------------------
# 5) Плейбуки (стандартные процессы)
# Назначение: готовые, статичные цепочки модулей под частые задачи.
# -----------------------------------------------------------------------------
WorkflowPlaybooks:
 Playbook_Strategic_Content_Generation:
 Playbook_Rapid_Business_Intelligence:
 Playbook_Proactive_Risk_Management: [guard-fomo, analyze-5w1h, solve-triz, execute-ifr]

# -----------------------------------------------------------------------------
# 6) Анти-ловушки (системные протоколы отказоустойчивости)
# Назначение: встроенные предохранители от типовых сбоев.
# -----------------------------------------------------------------------------
SystemResilience:
 AntiTrapProtocols:
   Trap_NoFrames: Mitigation_SchemaValidation_and_Triage
   Trap_NoRole: Mitigation_Hardcoded_Module_Roles
   Trap_LongChain: Mitigation_Task_Decomposition_by_Orchestrator
   Trap_NoVerification: Mitigation_Internal_QA_Loop
   Trap_MemoryLapse: Mitigation_State_Management_by_Orchestrator
   Trap_NoFormat: Mitigation_Strict_Output_Schemas
   Trap_NoFeedback: Mitigation_Copilot_Mode_and_QA_Loop

# -----------------------------------------------------------------------------
# 7) Конфигурация аналитического агента (среда выполнения)
# Назначение: параметры для безопасной интеграции, хранения состояния и аудита.
# -----------------------------------------------------------------------------
agent_core:
 agent_id: "analytics-agent-01"
 backend_gateway_url: "[URL_REMOVED]"
 service_endpoints:
   get_git_diff: "/api/v1/get-diff"
security:
 backend_authentication:
   method: oauth2_google
 csp_directives: "default-src 'self'"
 data_sanitization_rules: [{pattern: "(?i)password=", action: "redact"}]
state_management:
 strategy: hybrid
 workflow_storage: {key_prefix: "agent_state_"}
 audit_log_storage: {database_name: "AgentAuditDB", version: 1}
logging_and_telemetry:
 log_level: INFO
 telemetry_endpoint: null # "[URL_REMOVED]"
 sampling_rate: 0.25
protocols:
 proof_of_correction:
   providers: [{name: github, type: git, api_base: "[URL_REMOVED]", endpoints: {pr_diff: "/repos/{owner}/{repo}/pulls/{pull_number}"}}]
   ui_injection:
     trigger_selectors: ["div.agent-message[data-action='verify']"]
     injection_point_selector: ".message-footer"
     status_templates: {PENDING: "...", VERIFIED: "...", FAILED: "..."}
   artifact_parsing_rules: {jenkins_log: {success_pattern: "Finished: SUCCESS", failure_pattern: "Finished: FAILURE"}}
 agent_compliance_audit:
   agent_models: [{agent_id: "agent-builder-v1.2", expected_dom_mutations: [".builder-card.added"]}]
   monitoring_strategies:
     dom_observer_config: {childList: true, subtree: true, attributes: true, attributeFilter: ["class", "style"]}
     event_listener_config: ["builder-action-complete", "tester-result-reported"]
   rules_engine:
     rules:
       - if: {agent_id: "agent-builder-v1.2", event_type: "dom_mutation", mutation_details: "does_not_match_expected"}
         then: SET_STATUS_REGRESSION
         action: SHOW_UI_ALERT_LOW

# -----------------------------------------------------------------------------
# 8) Аналитический движок (для модулей, требующих поиска и анализа)
# Назначение: трёхцикловый поиск, валидация и самокритика.
# -----------------------------------------------------------------------------
analysis_engine:
 search_providers: ["mdn", "official_docs", "so"]
 funnel_criteria:
   source_credibility: [{pattern: "developer.mozilla.org", weight: 1.0}, {pattern: "stackoverflow.com", weight: 0.8}]
   evidence_strength: [{keyword: "<code>", weight: 0.5}, {keyword: "example", weight: 0.3}]
   recency: {max_age_days: 730, penalty_per_year: 0.2}
 self_criticism_engine:
   output_template: |
     Основная рекомендация: {recommendation}
     Потенциальные слабые стороны: {weaknesses}
     Альтернативные гипотезы: {alternatives}
     Оценка уверенности: {score}%
  confidence_score_factors: [{factor: "source_quality", weight: 0.5}, {factor: "contradictions", weight: -0.5}]

# -----------------------------------------------------------------------------
# 9) Форматы вывода (стандарты)
# Назначение: обеспечение консистентности и машиночитаемости результатов.
# -----------------------------------------------------------------------------
output_formats:
 text: "Markdown"
 table: "Markdown or JSON"
 report: "PDF/HTML with ToC"
 logs: "JSONL"

# -----------------------------------------------------------------------------
# 10) Чек-лист самопроверки («Check before send»)
# Назначение: финальная проверка перед отправкой результата пользователю.
# -----------------------------------------------------------------------------
pre_send_checklist:
 - "Соответствует ли результат ИКР и KPI?"
 - "Указаны ли источники и уровень уверенности?"
 - "Результат ясен и не содержит 'воды'?"
 - "Выдержан ли требуемый формат вывода?"
 - "Пройдены ли все релевантные анти-ловушки?"

Источники
            1. Настройка Агента и Анализ Директив.pdf
            2. DefendAI – AgentOps Platform for AI Security – Discover, Secure ..., дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            3. AI Agent Frameworks: Choosing the Right Foundation for Your Business | IBM, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            4. AgentDesk - DuploCloud, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            5. Use agent mode in VS Code, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            6. Writing Effective Prompts for AI Agent Creation - SysAid Documentation, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            7. Building a hivemind: A deep-dive on multi-agent systems - Pigment, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            8. What is a Multi-Agent System? | IBM, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            9. Do We Actually Need Multi-Agent AI Systems? : r/AI_Agents - Reddit, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            10. What are AI agents? Definition, examples, and types | Google Cloud, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            11. AI Agents and Solutions - Azure Cosmos DB | Microsoft Learn, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            12. How to Build AI Agents Using Plan-and-Execute Loops - WillowTree Apps, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            13. Vertex AI Agent Builder | Google Cloud, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            14. What is AI Agent Planning? | IBM, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            15. What Are AI Agents? | IBM, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            16. Plan-and-Execute - GitHub Pages, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            17. Plan-and-Execute Agents - LangChain Blog, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            18. Hierarchical task network - Wikipedia, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            19. Hierarchical Planning In Artificial Intelligence - Applied AI Course, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            20. Hierarchical Planning | Grav, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            21. Hierarchical Planning in AI - GeeksforGeeks, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            22. Hierarchical Task Network (HTN) Planning in AI - GeeksforGeeks, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            23. [1403.7426] An Overview of Hierarchical Task Network Planning - arXiv, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            24. Project Planning and Scheduling AI Agent | ClickUp™, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            25. When to Replan? an Adaptive Replanning Strategy for Autonomous Navigation Using Deep Reinforcement Learning - Infovaya, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            26. Development of a Dynamic Path Planning System for Autonomous Mobile Robots Using a Multi-Agent System Approach - PubMed Central, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            27. Dynamic Planner: Adaptive & Efficient Strategies - Emergent Mind, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            28. Development of a Dynamic Path Planning System for Autonomous Mobile Robots Using a Multi-Agent System Approach - PubMed, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            29. Dynamic Replanning using Multi-Agent Systems and Asset Administration Shells | Request PDF - ResearchGate, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            30. multi-agent planning - YODA Lab, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            31. Crews - CrewAI Documentation, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            32. Planning - CrewAI, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]
            33. LangChain, дата последнего обращения: сентября 27, 2025, [URL_REMOVED]